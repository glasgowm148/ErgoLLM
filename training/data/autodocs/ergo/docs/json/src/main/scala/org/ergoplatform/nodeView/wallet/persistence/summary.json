{
  "folderName": "persistence",
  "folderPath": ".autodoc/docs/json/src/main/scala/org/ergoplatform/nodeView/wallet/persistence",
  "url": "https://github.com/ergoplatform/ergo/.autodoc/docs/json/src/main/scala/org/ergoplatform/nodeView/wallet/persistence",
  "files": [
    {
      "fileName": "Balance.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/wallet/persistence/Balance.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/wallet/persistence/Balance.scala",
      "summary": "The code in this file defines a case class called `Balance` and a companion object with a method to create a `Balance` instance from a `TrackedBox` object. \n\nThe `Balance` case class has three fields: `id`, `value`, and `assets`. The `id` field is of type `EncodedBoxId`, which is a type alias for `String`. The `value` field is of type `Long` and represents the value of the box. The `assets` field is a `Map` that maps `EncodedTokenId` (also a type alias for `String`) to `Long`, representing the amount of each asset held in the box.\n\nThe companion object has a single method, also called `apply`, which takes a `TrackedBox` object and returns a `Balance` instance. The `apply` method first extracts the `id` of the box using the `encodedBoxId` method from the `IdUtils` object. It then extracts the `value` of the box and creates a `Map` of the additional tokens held in the box using the `encodedTokenId` method and the `toMap` method. The resulting `Map` is assigned to the `assets` field of the `Balance` instance.\n\nThis code is likely used in the larger project to represent the balance of a wallet. A wallet can hold multiple boxes, each containing a certain amount of value and assets. The `Balance` class provides a convenient way to represent this information in a single object. The `apply` method in the companion object allows for easy creation of a `Balance` instance from a `TrackedBox` object, which is likely used extensively in the wallet functionality of the project.\n\nExample usage:\n\n```\nimport org.ergoplatform.nodeView.wallet.persistence.Balance\nimport org.ergoplatform.wallet.boxes.TrackedBox\n\nval trackedBox: TrackedBox = // get a tracked box from somewhere\nval balance: Balance = Balance(trackedBox)\nprintln(balance.value) // prints the value of the box\nprintln(balance.assets) // prints the assets held in the box\n```",
      "questions": "1. What is the purpose of the `Balance` class and how is it used in the `ergo` project?\n   - The `Balance` class represents the balance of a wallet and includes the value of the wallet and any assets it holds. It is used in the `ergo` project for wallet persistence.\n2. What is the `apply` method in the `Balance` object and how does it work?\n   - The `apply` method takes a `TrackedBox` object and creates a new `Balance` object from it. It extracts the encoded box ID, value, and any additional tokens from the `TrackedBox` and creates a `Map` of encoded token IDs and their corresponding values.\n3. What is the purpose of the `EncodedBoxId` and `EncodedTokenId` classes and how are they used in this code?\n   - The `EncodedBoxId` and `EncodedTokenId` classes are used to encode box and token IDs as strings for storage and retrieval purposes. They are used in this code to encode the box and token IDs in the `Balance` class."
    },
    {
      "fileName": "OffChainRegistry.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/wallet/persistence/OffChainRegistry.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/wallet/persistence/OffChainRegistry.scala",
      "summary": "The `OffChainRegistry` class is responsible for holding version-agnostic off-chain data in runtime memory. This data includes off-chain boxes, which are needed to obtain wallet state in regards to unconfirmed transactions without reprocessing them on each request. The class takes three parameters: `height`, which is the latest processed block height; `offChainBoxes`, which are boxes from off-chain transactions; and `onChainBalances`, which is an on-chain balances snapshot required to calculate off-chain indexes. \n\nThe `OffChainRegistry` class has three methods. The first method, `digest`, calculates the off-chain index considering on-chain balances. It does this by summing the values of the off-chain balances and on-chain balances and then creating a map of the assets. The second method, `updateOnTransaction`, updates the registry on receiving a new off-chain transaction. It does this by filtering out spent boxes and adding new boxes. The third method, `updateOnBlock`, updates the balances snapshot according to a new block applied. It does this by filtering out on-chain boxes and updating the on-chain balances.\n\nThe `OffChainRegistry` class is used in the larger project to hold off-chain data in memory. This is useful for obtaining wallet state in regards to unconfirmed transactions without reprocessing them on each request. The class can be initialized using the `init` method of the `OffChainRegistry` object. This method takes a `walletRegistry` parameter and returns an `OffChainRegistry` object. \n\nExample usage:\n\n```\nval walletRegistry: WalletRegistry = ...\nval offChainRegistry: OffChainRegistry = OffChainRegistry.init(walletRegistry)\n```",
      "questions": "1. What is the purpose of the `OffChainRegistry` class?\n- The `OffChainRegistry` class holds off-chain data in runtime memory, which is needed to obtain wallet state in regards to unconfirmed transactions without reprocessing them on each request.\n\n2. What is the `digest` property of the `OffChainRegistry` class?\n- The `digest` property is an off-chain index considering on-chain balances, which is calculated based on the off-chain boxes and on-chain balances snapshot.\n\n3. What is the purpose of the `updateOnBlock` method in the `OffChainRegistry` class?\n- The `updateOnBlock` method updates the balances snapshot according to a new block applied, by filtering out the on-chain boxes and updating the off-chain boxes and on-chain balances snapshot."
    },
    {
      "fileName": "WalletDigest.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/wallet/persistence/WalletDigest.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/wallet/persistence/WalletDigest.scala",
      "summary": "The code defines a WalletDigest class that holds aggregate wallet data, including off-chain data, with no need for re-processing it on each request. The WalletDigest class has three fields: height, walletBalance, and walletAssetBalances. The height field corresponds to the wallet state digest, while the walletBalance field holds the wallet balance in nanoErgs. The walletAssetBalances field holds asset balances in the form of a sequence of tuples, where each tuple contains an EncodedTokenId and a Long value representing the asset balance.\n\nThe code also defines a WalletDigestSerializer object that extends the ScorexSerializer trait. The WalletDigestSerializer object provides serialization and deserialization methods for the WalletDigest class. The serialize method takes a WalletDigest object and a Writer object and writes the WalletDigest object to the Writer object. The parse method takes a Reader object and returns a WalletDigest object.\n\nThe code also defines an empty WalletDigest object that has a height of ErgoHistory.EmptyHistoryHeight, a walletBalance of 0, and an empty walletAssetBalances sequence. The empty WalletDigest object is used as a default value for the WalletDigest class.\n\nThe WalletDigest class and WalletDigestSerializer object are likely used in the larger project to store and retrieve wallet data efficiently. The WalletDigest class provides a way to store aggregate wallet data that can be quickly retrieved without the need for re-processing it on each request. The WalletDigestSerializer object provides a way to serialize and deserialize the WalletDigest class, which is useful for storing and retrieving the WalletDigest object from a database or file. \n\nExample usage:\n\n```scala\n// create a new WalletDigest object\nval walletDigest = WalletDigest(100, 5000000000L, Seq((\"token1\", 1000L), (\"token2\", 2000L)))\n\n// serialize the WalletDigest object\nval writer = new ByteArrayOutputStream()\nWalletDigestSerializer.serialize(walletDigest, writer)\nval serialized = writer.toByteArray()\n\n// deserialize the serialized data\nval reader = new ByteArrayInputStream(serialized)\nval deserialized = WalletDigestSerializer.parse(reader)\n\n// check if the deserialized object is equal to the original object\nassert(deserialized == walletDigest)\n```",
      "questions": "1. What is the purpose of the `WalletDigest` class?\n- The `WalletDigest` class holds aggregate wallet data, including off-chain data, without the need for re-processing it on each request.\n\n2. What is the `WalletDigestSerializer` object used for?\n- The `WalletDigestSerializer` object is used to serialize and deserialize instances of the `WalletDigest` class.\n\n3. What is the purpose of the `empty` method in the `WalletDigest` object?\n- The `empty` method returns an empty `WalletDigest` instance with a height of `ErgoHistory.EmptyHistoryHeight`, a wallet balance of 0, and an empty sequence of asset balances."
    },
    {
      "fileName": "WalletRegistry.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/wallet/persistence/WalletRegistry.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/wallet/persistence/WalletRegistry.scala",
      "summary": "The `WalletRegistry` class in the Ergo project provides access to version-sensitive wallet-specific indexes. It is responsible for managing wallet-related data, such as transactions, boxes (spent or unspent), and wallet status (height, balances). The class also provides methods for updating the wallet state based on new blocks and rolling back to a previous state.\n\nSome key methods in this class include:\n\n- `getBox(id: BoxId)`: Retrieves a wallet-related box with metadata by its identifier.\n- `allUnspentBoxes()`: Returns all unspent boxes in the wallet.\n- `unspentBoxes(scanId: ScanId)`: Returns unspent boxes related to a specific scan.\n- `walletUnspentBoxes()`: Returns unspent boxes belonging to the wallet (payments scan).\n- `getTx(id: ModifierId)`: Retrieves a wallet-related transaction with metadata by its identifier.\n- `allWalletTxs()`: Returns all wallet-related transactions.\n- `updateOnBlock(scanResults: ScanResults, blockId: ModifierId, blockHeight: Int)`: Updates the wallet state based on the data extracted from a block.\n\nThe `WalletRegistry` class also provides methods for updating the scans associated with a box, removing a scan from a box, and updating the wallet digest (aggregate wallet information).\n\nExample usage of the `WalletRegistry` class:\n\n```scala\nval walletRegistry = WalletRegistry(settings)\nval unspentBoxes = walletRegistry.allUnspentBoxes()\nval walletTransaction = walletRegistry.getTx(transactionId)\nwalletRegistry.updateOnBlock(scanResults, blockId, blockHeight)\n```\n\nIn summary, the `WalletRegistry` class is a crucial component in the Ergo project for managing wallet-related data and updating the wallet state based on new blocks and transactions.",
      "questions": "1. **What is the purpose of the `WalletRegistry` class?**\n\n   The `WalletRegistry` class provides access to version-sensitive wallet-specific indexes, such as the current wallet status (height, balances), wallet-related transactions, and boxes (spent or not). It handles the storage and retrieval of wallet-related data and updates the wallet state based on new blocks and transactions.\n\n2. **How does the `updateOnBlock` method work?**\n\n   The `updateOnBlock` method updates the wallet state based on the data extracted from a block (outputs created and spent along with corresponding transactions). It updates the wallet-specific indexes, such as unspent and spent boxes, transactions, and wallet digest (height, balances). The method performs a versioned update to maintain the history of changes.\n\n3. **What is the purpose of the `KeyValuePairsBag` class?**\n\n   The `KeyValuePairsBag` class is a helper class that collects data for versioned database updates. It holds key-value pairs to be inserted and keys to be removed from the database. It provides methods to apply these updates to a given `LDBVersionedStore`, either as a versioned or non-versioned transaction."
    },
    {
      "fileName": "WalletStorage.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/wallet/persistence/WalletStorage.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/wallet/persistence/WalletStorage.scala",
      "summary": "The `WalletStorage` class is responsible for persisting the version-agnostic wallet actor's mutable state. This mutable state is not subject to rollbacks in case of forks, so it contains data that does not have different versions unlike blockchain-related objects. The data that is stored includes tracked addresses, derivation paths, changed addresses, ErgoStateContext, and external scans. \n\nThe class provides methods to read, write, and remove data from the database. For example, `addPublicKeys` is used to store wallet-related public keys in the database, while `getPublicKey` is used to read the public key corresponding to a provided derivation path. The `updateStateContext` method writes the state context into the database, while `readStateContext` reads the state context from the database. \n\nThe class also provides methods to manage external scans. The `addScan` method registers a new scan, while `removeScan` removes an existing scan from the database. The `getScan` method retrieves a scan by its identifier, and `allScans` reads all the scans from the database. \n\nThe `WalletStorage` class is used in the larger project to persist the wallet's mutable state. It is used by the wallet actor to store and retrieve data from the database. For example, when a new public key is generated, it is stored in the database using the `addPublicKeys` method. When the wallet needs to read the state context, it uses the `readStateContext` method to retrieve it from the database. \n\nOverall, the `WalletStorage` class provides a way to persist the wallet's mutable state, which is essential for the wallet to function properly. It is used to store and retrieve data from the database, and it provides methods to manage external scans.",
      "questions": "1. What is the purpose of this code and what data does it persist?\n- This code persists version-agnostic wallet actor's mutable state, which includes tracked addresses, derivation paths, changed addresses, ErgoStateContext, and external scans.\n2. What external dependencies does this code have?\n- This code depends on several external libraries, including Guava, Scorex, and Blake2b256.\n3. What methods are available for reading and writing data to the database?\n- Methods available for reading and writing data to the database include `addPublicKeys`, `getPublicKey`, `readAllKeys`, `updateStateContext`, `readStateContext`, `updateChangeAddress`, `readChangeAddress`, `addScan`, `removeScan`, `getScan`, and `allScans`."
    }
  ],
  "folders": [],
  "summary": "The code in the `persistence` folder is responsible for managing wallet-related data and persisting the wallet's mutable state. It provides classes and methods for representing wallet balances, handling off-chain data, and managing wallet-specific indexes.\n\nFor example, the `Balance` class represents the balance of a wallet, including the value and assets held in a box. It can be easily created from a `TrackedBox` object using the `apply` method in its companion object:\n\n```scala\nimport org.ergoplatform.nodeView.wallet.persistence.Balance\nimport org.ergoplatform.wallet.boxes.TrackedBox\n\nval trackedBox: TrackedBox = // get a tracked box from somewhere\nval balance: Balance = Balance(trackedBox)\nprintln(balance.value) // prints the value of the box\nprintln(balance.assets) // prints the assets held in the box\n```\n\nThe `OffChainRegistry` class holds off-chain data in runtime memory, which is useful for obtaining wallet state in regards to unconfirmed transactions without reprocessing them on each request. It can be initialized using the `init` method of the `OffChainRegistry` object:\n\n```scala\nval walletRegistry: WalletRegistry = ...\nval offChainRegistry: OffChainRegistry = OffChainRegistry.init(walletRegistry)\n```\n\nThe `WalletDigest` class holds aggregate wallet data, including off-chain data, and can be serialized and deserialized using the `WalletDigestSerializer` object:\n\n```scala\n// create a new WalletDigest object\nval walletDigest = WalletDigest(100, 5000000000L, Seq((\"token1\", 1000L), (\"token2\", 2000L)))\n\n// serialize the WalletDigest object\nval writer = new ByteArrayOutputStream()\nWalletDigestSerializer.serialize(walletDigest, writer)\nval serialized = writer.toByteArray()\n\n// deserialize the serialized data\nval reader = new ByteArrayInputStream(serialized)\nval deserialized = WalletDigestSerializer.parse(reader)\n\n// check if the deserialized object is equal to the original object\nassert(deserialized == walletDigest)\n```\n\nThe `WalletRegistry` class manages wallet-related data and updates the wallet state based on new blocks and transactions:\n\n```scala\nval walletRegistry = WalletRegistry(settings)\nval unspentBoxes = walletRegistry.allUnspentBoxes()\nval walletTransaction = walletRegistry.getTx(transactionId)\nwalletRegistry.updateOnBlock(scanResults, blockId, blockHeight)\n```\n\nFinally, the `WalletStorage` class persists the wallet's mutable state and provides methods to read, write, and remove data from the database:\n\n```scala\nval walletStorage = WalletStorage(settings)\nwalletStorage.addPublicKeys(publicKeys)\nval publicKey = walletStorage.getPublicKey(derivationPath)\nwalletStorage.updateStateContext(stateContext)\n```\n\nIn summary, the code in the `persistence` folder plays a crucial role in managing wallet-related data and persisting the wallet's mutable state in the Ergo project. It provides classes and methods for handling wallet balances, off-chain data, and wallet-specific indexes, which are essential for the wallet to function properly.",
  "questions": ""
}