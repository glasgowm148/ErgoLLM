{
  "folderName": "extension",
  "folderPath": ".autodoc/docs/json/src/main/scala/org/ergoplatform/modifiers/history/extension",
  "url": "https://github.com/ergoplatform/ergo/.autodoc/docs/json/src/main/scala/org/ergoplatform/modifiers/history/extension",
  "files": [
    {
      "fileName": "Extension.scala",
      "filePath": "src/main/scala/org/ergoplatform/modifiers/history/extension/Extension.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/modifiers/history/extension/Extension.scala",
      "summary": "The code defines the Extension class, which represents a key-value storage section of an Ergo block. The class contains a sequence of key-value records, where the key is a 2-byte array and the value is a 64-byte array at most. The class also has a mandatory headerId field, which is the ID of the corresponding header.\n\nThe Extension class extends the ExtensionCandidate class and implements the NonHeaderBlockSection trait. The modifierTypeId field is set to Extension.modifierTypeId, which is of type NetworkObjectTypeId.Value. The class also has a serializer field of type ScorexSerializer[Extension], which is implemented by the ExtensionSerializer object.\n\nThe object Extension contains several utility methods and constants. The kvToLeaf method takes a key-value record and returns a byte array that concatenates the length of the key, the key itself, and the value. The merkleTree method takes a sequence of key-value records, converts them to leaf data using the kvToLeaf method, and returns a Merkle tree of type MerkleTree[Digest32]. The object also defines the modifierTypeId constant, which is set to ExtensionTypeId.value, and provides JSON encoding and decoding for the Extension class.\n\nThe Extension class is used in the larger Ergo project to store additional data in Ergo blocks. The key-value storage can be used to store various types of data, such as system parameters, interlinks vectors, and validation rules. The Extension class can be serialized and deserialized using the ExtensionSerializer object, and can be encoded and decoded to JSON using the jsonEncoder and jsonDecoder methods defined in the Extension object. The merkleTree method can be used to calculate the Merkle root of the key-value storage section, which can be used for various purposes, such as verifying the integrity of the data.",
      "questions": "1. What is the purpose of the `Extension` class and what does it contain?\n- The `Extension` class represents an extension section of an Ergo block and contains key-value storage represented as a sequence of byte arrays with mandatory and optional fields.\n2. What are the predefined key prefixes and what are they used for?\n- The predefined key prefixes are `SystemParametersPrefix`, `InterlinksVectorPrefix`, and `ValidationRulesPrefix`. They are used to identify different types of fields in the key-value storage.\n3. What is the purpose of the `merkleTree` method and how is it used?\n- The `merkleTree` method takes a sequence of key-value pairs and returns a Merkle tree of type `MerkleTree[Digest32]`. It is used to calculate the digest of the extension section, which is used in the `Extension` class's `toString` method and in the `jsonEncoder` implicit method."
    },
    {
      "fileName": "ExtensionCandidate.scala",
      "filePath": "src/main/scala/org/ergoplatform/modifiers/history/extension/ExtensionCandidate.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/modifiers/history/extension/ExtensionCandidate.scala",
      "summary": "The `ExtensionCandidate` class is a section of an extension block that holds key-value data. It is useful when a header is not formed yet. The class takes a sequence of key-value pairs as input, where keys must be of 2 bytes length, unique, and values must be no more than 64 bytes long. The data must be 32,768 bytes max. \n\nThe class has several methods that allow for the manipulation of the data. The `merkleTree` method creates a Merkle tree from the key-value pairs. The `digest` method returns the root hash of the Merkle tree. The `interlinksMerkleTree` method creates a Merkle tree from the key-value pairs that have a key starting with the `InterlinksVectorPrefix`. The `interlinksDigest` method returns the root hash of the interlinks Merkle tree. \n\nThe `toExtension` method creates an `Extension` object from the `ExtensionCandidate` object and a header ID. The `++` method concatenates two `ExtensionCandidate` objects. The `proofFor` method returns a Merkle proof for a given key. The `batchProofFor` method constructs a `BatchMerkleProof` for a list of interlinks. \n\nThe `ExtensionCandidate` object has an `apply` method that creates a new `ExtensionCandidate` object from a sequence of key-value pairs. \n\nOverall, the `ExtensionCandidate` class provides a way to store and manipulate key-value data in an extension block. It allows for the creation of Merkle trees and proofs, as well as concatenation of multiple `ExtensionCandidate` objects. This class is likely used in the larger project to handle extension blocks and their associated data. \n\nExample usage:\n\n```\nval fields = Seq((Array[Byte](0, 1), Array[Byte](1, 2, 3)), (Array[Byte](0, 2), Array[Byte](4, 5, 6)))\nval extCandidate = ExtensionCandidate(fields)\nval merkleTree = extCandidate.merkleTree\nval digest = extCandidate.digest\nval interlinksMerkleTree = extCandidate.interlinksMerkleTree\nval interlinksDigest = extCandidate.interlinksDigest\nval ext = extCandidate.toExtension(ModifierId @@ Array.fill(32)(1: Byte))\nval newFields = Seq((Array[Byte](0, 3), Array[Byte](7, 8, 9)))\nval newExtCandidate = ExtensionCandidate(newFields)\nval concatenated = extCandidate ++ newExtCandidate\nval proof = extCandidate.proofFor(Array[Byte](0, 1))\nval batchProof = extCandidate.batchProofFor(Array[Byte](1, 2), Array[Byte](2, 3))\n```",
      "questions": "1. What is the purpose of the `ExtensionCandidate` class?\n- The `ExtensionCandidate` class represents an extension block section without a header ID, which is useful when a header is not formed yet.\n\n2. What is the `++` method used for in the `ExtensionCandidate` class?\n- The `++` method is used to concatenate two `ExtensionCandidate` objects together.\n\n3. What is the `batchProofFor` method used for in the `ExtensionCandidate` class?\n- The `batchProofFor` method constructs a `BatchMerkleProof` for a list of interlinks, but only accounts for interlink vector fields in the extension."
    },
    {
      "fileName": "ExtensionSerializer.scala",
      "filePath": "src/main/scala/org/ergoplatform/modifiers/history/extension/ExtensionSerializer.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/modifiers/history/extension/ExtensionSerializer.scala",
      "summary": "The `ExtensionSerializer` object is responsible for serializing and deserializing `Extension` objects. An `Extension` is a modifier that can be added to a block in the Ergo blockchain. It contains a header ID and a set of key-value pairs, where the keys are byte arrays and the values are byte arrays of variable length.\n\nThe `serialize` method takes an `Extension` object and a `Writer` object and writes the header ID and the key-value pairs to the writer. The header ID is converted to a byte array using the `idToBytes` method, and the key-value pairs are written to the writer as follows: first, the key is written as a byte array, then the length of the value is written as a single byte, and finally the value itself is written as a byte array.\n\nThe `parse` method takes a `Reader` object and reads the header ID and the key-value pairs from it to create an `Extension` object. The header ID is read as a byte array using the `getBytes` method, and the key-value pairs are read as follows: first, the key is read as a byte array, then the length of the value is read as a single byte, and finally the value itself is read as a byte array. The `fieldsView` variable is a lazy stream of key-value pairs that is created using the `map` method and the `toStream` method. The `takeWhile` method is used to limit the number of key-value pairs that are read to the maximum extension size defined in the `Constants` object.\n\nOverall, the `ExtensionSerializer` object is an important part of the Ergo blockchain project, as it allows `Extension` objects to be serialized and deserialized for storage and transmission. Here is an example of how it might be used:\n\n```\nval extension = Extension(headerId, fields, Some(size))\nval writer = new ByteArrayOutputStream()\nExtensionSerializer.serialize(extension, writer)\nval bytes = writer.toByteArray()\n\n// ...\n\nval reader = new ByteArrayInputStream(bytes)\nval extension2 = ExtensionSerializer.parse(reader)\n```",
      "questions": "1. What is the purpose of the `Extension` class that this serializer is designed for?\n- The `ExtensionSerializer` is designed to serialize and parse instances of the `Extension` class.\n2. What is the format of the serialized data produced by this serializer?\n- The serialized data consists of the header ID followed by a sequence of key-value pairs, where each key is a byte array and each value is a byte array of variable length.\n3. What are the constraints on the size of the serialized data that can be parsed by this serializer?\n- The serialized data must be no larger than `Constants.MaxExtensionSizeMax` bytes, and the total size of the key-value pairs must not exceed this limit."
    }
  ],
  "folders": [],
  "summary": "The code in this folder is responsible for handling the `Extension` and `ExtensionCandidate` classes, which are used to store key-value data in Ergo blocks. These classes are essential for storing additional data in Ergo blocks, such as system parameters, interlinks vectors, and validation rules.\n\n`Extension.scala` defines the `Extension` class, which represents a key-value storage section of an Ergo block. It extends the `ExtensionCandidate` class and implements the `NonHeaderBlockSection` trait. The class contains utility methods and constants for working with key-value records, such as `kvToLeaf`, which converts a key-value record to a byte array, and `merkleTree`, which calculates the Merkle root of the key-value storage section.\n\n`ExtensionCandidate.scala` defines the `ExtensionCandidate` class, which is a section of an extension block that holds key-value data. It is useful when a header is not formed yet. The class provides methods for manipulating the data, such as creating Merkle trees and proofs, and concatenating multiple `ExtensionCandidate` objects.\n\n`ExtensionSerializer.scala` is responsible for serializing and deserializing `Extension` objects. It provides the `serialize` and `parse` methods, which allow `Extension` objects to be serialized and deserialized for storage and transmission.\n\nHere's an example of how these classes might be used:\n\n```scala\nval fields = Seq((Array[Byte](0, 1), Array[Byte](1, 2, 3)), (Array[Byte](0, 2), Array[Byte](4, 5, 6)))\nval extCandidate = ExtensionCandidate(fields)\nval merkleTree = extCandidate.merkleTree\nval digest = extCandidate.digest\nval interlinksMerkleTree = extCandidate.interlinksMerkleTree\nval interlinksDigest = extCandidate.interlinksDigest\nval ext = extCandidate.toExtension(ModifierId @@ Array.fill(32)(1: Byte))\nval newFields = Seq((Array[Byte](0, 3), Array[Byte](7, 8, 9)))\nval newExtCandidate = ExtensionCandidate(newFields)\nval concatenated = extCandidate ++ newExtCandidate\nval proof = extCandidate.proofFor(Array[Byte](0, 1))\nval batchProof = extCandidate.batchProofFor(Array[Byte](1, 2), Array[Byte](2, 3))\n\n// Serialize and deserialize an Extension object\nval extension = Extension(headerId, fields, Some(size))\nval writer = new ByteArrayOutputStream()\nExtensionSerializer.serialize(extension, writer)\nval bytes = writer.toByteArray()\n\n// ...\n\nval reader = new ByteArrayInputStream(bytes)\nval extension2 = ExtensionSerializer.parse(reader)\n```\n\nIn summary, the code in this folder is crucial for handling key-value data in Ergo blocks, providing methods for creating, manipulating, and serializing `Extension` and `ExtensionCandidate` objects. This functionality is essential for storing additional data in Ergo blocks and ensuring the integrity of the data through Merkle trees and proofs.",
  "questions": ""
}