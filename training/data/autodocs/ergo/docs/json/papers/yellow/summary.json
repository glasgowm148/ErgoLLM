{
  "folderName": "yellow",
  "folderPath": ".autodoc/docs/json/papers/yellow",
  "url": "https://github.com/ergoplatform/ergo/.autodoc/docs/json/papers/yellow",
  "files": [
    {
      "fileName": "YellowPaper.tex",
      "filePath": "papers/yellow/YellowPaper.tex",
      "url": "https://github.com/ergoplatform/ergo/papers/yellow/YellowPaper.tex",
      "summary": "This code is for a LaTeX document that describes the Ergo Platform, a conservative Proof-of-Work blockchain with a new contract language called ErgoTree. The document is structured into two main parts: the protocol and the reference implementation.\n\nThe protocol section covers various aspects of the Ergo Platform, such as the vision, state-oriented design, cryptographic primitives, and modes of operation. It also discusses the transaction format, validation rules, and proof-of-work. The reference implementation section provides details on the synchronization process and wallet functionality.\n\nThe document uses various LaTeX packages for formatting, such as color, graphicx, amssymb, amsthm, amsmath, and hyperref. It also defines several custom commands and environments for formatting and notation, such as newtheorem, def, and newcommand.\n\nAn example",
      "questions": "1. **What curve is used for the cryptographic primitives in this code?**\n\n   The code does not explicitly mention which elliptic curve is used for the cryptographic primitives. More information might be available in other parts of the project or documentation.\n\n2. **What is the purpose of the different modes of operation (Full-Node, Pruned Full-Node, Light Full-Node, and Light-SPV)?**\n\n   The different modes of operation are designed to accommodate various levels of security and resource requirements for nodes participating in the Ergo network. Full-Node provides the highest security and requires the most resources, while Light-SPV is designed for low-end hardware and mobile devices with reduced security requirements.\n\n3. **How are transaction validation rules enforced in this code?**\n\n   Transaction validation rules are enforced through a combination of stateless and stateful checks. Stateless checks can be performed using only the transaction data, while stateful checks require knowledge of the current state, such as the UTXO set. The specific rules for transaction validation are detailed in Section~\\ref{tx-validation}."
    },
    {
      "fileName": "block.tex",
      "filePath": "papers/yellow/block.tex",
      "url": "https://github.com/ergoplatform/ergo/papers/yellow/block.tex",
      "summary": "The code presented here provides documentation for the Ergo blockchain system, specifically the Ergo Modifiers. The Ergo block is divided into four parts: Header, BlockTransactions, ADProofs, and Extension. The Header contains the minimum amount of data required to synchronize the chain and check PoW correctness, as well as hashes of other sections. It also includes the block version, the ID of the parent block, the hash of ADProofs for transactions in a block, the root hash of a state after block application, the root hash of transactions in a block, the block timestamp, the current difficulty in a compressed form, the block height, the root hash of the extension section, the solution of Autolykos PoW puzzle, and votes for changes in system parameters.\n\nThe Extension section is a key-value storage for a variety of data. A key is always 2-bytes long, and the maximum size of a value is 64 bytes. The Extension section could be no more than 16,384 bytes. Some keys have predefined semantics. For example, if the first byte of a key equals to 0x00, then the second byte defines the parameter identifier, and the value defines the value of the parameter. Another predefined key is used for storing interlinks vector, where the first byte of the key is 0x01, the second one corresponds to the index of the link in the vector, and the value contains the actual link (32 bytes) prefixed with the number of times it appears in the vector (1 byte). Other prefixes may be used freely.\n\nThe purpose of this code is to provide a clear understanding of the structure and content of the Ergo block, specifically the Header and Extension sections. This information is essential for developers who want to build applications on top of the Ergo blockchain system. By understanding the structure and content of the Ergo block, developers can create more efficient and effective applications that take advantage of the unique features of the Ergo blockchain system. For example, developers can use the Extension section to store custom data that is specific to their application, allowing them to create more complex and sophisticated applications that are tailored to the needs of their users.",
      "questions": "1. What are the different parts of an Ergo block and what do they contain?\n- The Ergo block consists of four parts: Header, BlockTransactions, ADProofs, and Extension. The Header contains minimal data required to synchronize the chain and check PoW correctness, as well as hashes of other sections. BlockTransactions is a sequence of transactions included in the block, while ADProofs are proofs for transactions included in the corresponding BlockTransactions section of a block. Extension contains additional data that does not correspond to previous sections, including interlinks and current parameters of the chain.\n\n2. What fields are included in the Header section of an Ergo block?\n- The Header section of an Ergo block includes the following fields: version, parentId, ADProofsRoot, stateRoot, transactionsRoot, timestamp, nBits, height, extensionRoot, powSolution, and votes. Some of these fields may be calculated by the node itself if it is in a certain mode.\n\n3. What is the Extension section of an Ergo block and what kind of data does it store?\n- The Extension section of an Ergo block is a key-value storage for a variety of data. A key is always 2-bytes long, and the maximum size of a value is 64 bytes. The Extension section could be no more than of $16,384$ bytes. Some keys have predefined semantics, such as storing system parameter values or interlinks vector. Other prefixes may be used freely."
    },
    {
      "fileName": "compile.sh",
      "filePath": "papers/yellow/compile.sh",
      "url": "https://github.com/ergoplatform/ergo/papers/yellow/compile.sh",
      "summary": "This code is a shell script that compiles a LaTeX document called \"YellowPaper\" into a PDF file. The script first checks if the necessary LaTeX commands, pdflatex and bibtex, are installed on the system. If either command is not found, the script prints an error message and exits. \n\nAssuming both commands are available, the script then removes any existing PDF file called \"YellowPaper.pdf\" and compiles the LaTeX document using pdflatex and bibtex. The -shell-escape flag is used with both commands to allow for external programs to be executed during the compilation process. This is necessary for certain LaTeX packages that require external programs to generate graphics or perform other tasks.\n\nAfter the compilation is complete, the script checks if it was run from the same directory as the YellowPaper.tex file. If so, it removes all the auxiliary files generated during the compilation process, such as .aux and .log files, as well as the _minted-YellowPaper/ directory, which contains syntax-highlighted code listings if the minted package was used in the document.\n\nThis script can be used as part of a larger project that involves writing technical documents in LaTeX. By automating the compilation process, it saves time and ensures that the document is always up-to-date with the latest changes. The script can be run manually or as part of a continuous integration pipeline to automatically generate the PDF file whenever changes are made to the LaTeX document. \n\nExample usage:\n```\n$ cd path/to/ergo/docs\n$ sh compile_yellowpaper.sh\n```\nThis will compile the YellowPaper.tex file located in the current directory and generate a YellowPaper.pdf file.",
      "questions": "1. What is the purpose of this code?\n   \n   This code compiles a LaTeX document called \"YellowPaper\" into a PDF file, and removes any auxiliary files generated during the compilation process.\n\n2. What dependencies are required to run this code?\n   \n   This code requires the installation of pdflatex and bibtex. Additionally, it may require the installation of additional packages like fonts, etc.\n\n3. What is the significance of the \"YellowPaper\" file?\n   \n   The \"YellowPaper\" file is the LaTeX document that is being compiled into a PDF file."
    },
    {
      "fileName": "economy.tex",
      "filePath": "papers/yellow/economy.tex",
      "url": "https://github.com/ergoplatform/ergo/papers/yellow/economy.tex",
      "summary": "The code presented in this file outlines the economic properties of the Ergo blockchain. It describes the rules for the emission of Ergo coins and proposes a storage fee consensus mechanism to ensure the long-term survivability of the chain.\n\nThe Ergo emission will last for 2080799 blocks, which is approximately 8 years with a planned 2-minute block interval. During the first 525600 blocks (2 years), 75 Erg will be issued per block, and after that, the block reward will be reduced by 3 Erg every 64800 blocks (3 months). To fund the development, during the first 655200 blocks (2.5 years), the part of the block rewards that exceeds 67.5 will go to the foundation treasury instead of a miner.\n\nThe Ergo coins emission rule is defined explicitly by sigma-state transactional language, instead of having an implicit emission rule via a special type of transaction (e.g., coinbase transaction in Bitcoin). Total miners rewards of 93409132.5 Erg will be created in the genesis state in a box, protected by a script defined at https://git.io/fhgOq. This script allows a miner to take only a part of all coins every block. The transaction that spends this output should have exactly 2 outputs: the first one should have the same protecting script and contain all input coins minus the current block reward, while the second one may be collected by the current block miner after at least 720 blocks delay.\n\nTotal foundation rewards will be kept in the genesis state in a box with 4330791.5 Erg and will be protected by the script defined at https://git.io/fhoqw. The first output of the transaction that spends this box should at least have the value of the remaining treasury. In addition, conditions from R4 register of this box should be satisfied, allowing to protect this output from undesirable spent. At the beginning, R4 register will contain 2-of-3 multisignature proposition with the hardcoded public keys.\n\nTo ensure the long-term survivability of the chain, the proposed storage fee consensus mechanism outlines two properties. Firstly, coins protected by keys being lost should be returned into circulation. Otherwise, after the end of the emission period, the amount of coins in circulation will always decrease and eventually reach zero. Secondly, nothing should be kept in the state forever and for free. Otherwise, the size of the state is always increasing with time, thus reducing clients' performance.\n\nThe proposed storage fee consensus mechanism requires that register R3 of a box contains tuple $(creation\\_height, tx\\_id || out\\_num)$, where $creation\\_height$ provided by a user is used to determine the block height at the moment of transaction generation. Transaction can only be put in the block of height $h$ if for every created box its $creation\\_height \\le h$. Once the subsidized period for the box ends, anyone (presumably, a miner) can create a new box with the same content (including the guarding script) except the monetary value and $R3$ contents. The monetary value is to be reduced by $K \\cdot B$ maximum, where $B$ is the spent box (self) size, and $K$ is the storage cost for the period $SP$. Thus, the difference is to be paid to the miner. If the box value is less than the storage fee, all the box content, including tokens, could be spent by the miner.\n\nFor efficient lookup, the proposed storage fee consensus mechanism requires a spending proof for an expired box to be just a context extension that contains only an index of an output that is trying to spend the box. The variable identifier for the index in the extension is $127$. The proposed concrete parameters for the storage fee consensus mechanism are $SP = 1051200 \\approx 4$ years and $K$ - cost of storage of 1 byte of data in a State for the period of $SP$ blocks. The cost should be determined by miner votes, $1250000 (nanoErg/SP)$ by default, and the maximum value is $2500000$.",
      "questions": "1. What is the emission schedule for Ergo coins?\n- Ergo emission will last for 2080799 blocks (8 years with planned 2 minute block interval) --- for the first 525600 blocks (2 years) 75 Erg will be issued per block and after that the block reward will be reduced by 3 Erg every 64800 blocks (3 months).\n\n2. How is the Ergo coin emission rule defined?\n- Instead of having an implicit emission rule via a special type of transaction (e.g. coinbase transaction in Bitcoin), Ergo coins emission rule is defined explicitly by sigma-state transactional language.\n\n3. What are the storage fee consensus rules for Ergo?\n- Once the subsidized period for the box ends, anyone (presumably, a miner) can create a new box with the exactly the same content (including the guarding script) except the monetary value and R3 contents. The monetary value is to reduced by K * B maximum, where B is the spent box (self) size and K is the storage cost for the period SP."
    },
    {
      "fileName": "modifiersProcessing.tex",
      "filePath": "papers/yellow/modifiersProcessing.tex",
      "url": "https://github.com/ergoplatform/ergo/papers/yellow/modifiersProcessing.tex",
      "summary": "The code in this file describes the processing algorithm for Ergo modifiers in all security modes. Ergo is a blockchain system that has in-memory and persistent modifiers. The in-memory modifiers include Transaction, TransactionIdsForHeader, and UTXOSnapshotManifest. The persistent modifiers include BlockTransactions, ADProofs, Header, UTXOSnapshotChunk, and PoPoWProof. Ergo has parameters that determine the concrete security regime, such as ADState, VerifyTransactions, PoPoWBootstrap, BlocksToKeep, and MinimalSuffix. The mode from \"multimode.md\" can be determined based on these parameters.\n\nThe code includes functions for modifiers processing and bootstrap. The updateHeadersChainToBestInNetwork() function sends an ErgoSyncInfo message to connected peers, gets a response with INV message containing ids of blocks better than the best block, requests headers for all ids, and updates the header chain to the best in the network. The bootstrap function has two parts: download headers and download initial state to start processing transactions. If PoPoW is enabled, the function sends GetPoPoWProof for all connections and applies it to History. Otherwise, it calls the updateHeadersChainToBestInNetwork() function. If ADState is true, the function initializes the state with the state roothash from the block header BlocksToKeep ago. If BlocksToKeep is negative or greater than History.headersHeight, the function initializes the state with the genesis state. Otherwise, it requests the historical UTXOSnapshotManifest for at least BlocksToKeep back, requests chunks from the sender or a random full node, and applies the chunk to State. If the State's best header is the same as History's best header, the function does nothing. If VerifyTransactions is false, the function updates the State rootshash to the best header in history. Otherwise, it requests transaction ids from all headers without transactions, applies them to Mempool, requests transactions that are not in Mempool, applies the transactions to Mempool, broadcasts INV for the transaction, and gets BlockTransactions. \n\nOverall, this code is responsible for processing Ergo modifiers and updating the state based on the security regime. It is a crucial part of the Ergo project, as it ensures the correctness and security of the blockchain system.",
      "questions": "1. What are the different types of modifiers in Ergo and how do they differ from other blockchain systems?\n- The different types of modifiers in Ergo are in-memory and persistent modifiers. They differ from other blockchain systems because Ergo's in-memory modifiers include Transaction, TransactionIdsForHeader, and UTXOSnapshotManifest, while its persistent modifiers include BlockTransactions, ADProofs, Header, UTXOSnapshotChunk, and PoPoWProof.\n\n2. How does Ergo determine its security regime?\n- Ergo determines its security regime based on the values of its parameters, which include ADState, VerifyTransactions, PoPoWBootstrap, BlocksToKeep, and MinimalSuffix. Depending on the combination of these parameters, Ergo can be in full, pruned-full, light-full, light-spv, or light-full-PoPoW mode.\n\n3. What is the process for updating the state to the best headers height in Ergo?\n- The process for updating the state to the best headers height in Ergo involves downloading the historical UTXOSnapshotManifest for at least BlocksToKeep back, requesting the UTXOSnapshotChunk from the sender or a random full node, and applying the chunk to the state. If the state is successfully updated, Ergo will remove BlockTransactions and ADProofs older than BlocksToKeep from history. If the state is not successfully updated, Ergo will drop the header from history."
    },
    {
      "fileName": "modifiersValidation.tex",
      "filePath": "papers/yellow/modifiersValidation.tex",
      "url": "https://github.com/ergoplatform/ergo/papers/yellow/modifiersValidation.tex",
      "summary": "The code presented is a list of validation rules that should be performed by every node in the Ergo network. The rules are divided into four categories: transaction validation, header validation, block sections validation, and block application to state validation. Each rule is enumerated and initially activated, but some rules may be disabled later by a miner voting via soft forks, while new rules may also be added at the same time.\n\nThe transaction validation rules ensure that every transaction in the network is valid and does not violate any consensus-critical rules. These rules include checking that a transaction has at least one input and output, that the number of inputs and outputs does not exceed a certain limit, that the sum of output values does not exceed a certain limit, and that the scripts of all transaction inputs pass verification.\n\nThe header validation rules ensure that every block header in the network is valid and does not violate any consensus-critical rules. These rules include checking that the genesis header has the correct parent ID and height, that the header timestamp is greater than the parent's, that the header contains correct PoW solution and required difficulty, and that the parent header is not marked as invalid.\n\nThe block sections validation rules ensure that every block section in the network is valid and does not violate any consensus-critical rules. These rules include checking that the block sections correspond to the declared header, that the size of the block transactions section does not exceed a certain limit, and that the accumulated cost of block transactions does not exceed a certain limit.\n\nThe extension validation rules ensure that every extension in the network is valid and does not violate any consensus-critical rules. These rules include checking that the size of the extension section does not exceed a certain limit, that the interlinks are packed properly and have the correct structure, that the extension fields key and value lengths do not exceed certain limits, and that the extension does not contain duplicate keys.\n\nFinally, the block application to state validation rules ensure that every block in the network is applied to the state AVL+ tree successfully and that the calculated AVL+ digest is equal to the one written in the block header.\n\nOverall, this code is an essential part of the Ergo project as it ensures that every node in the network follows the same consensus-critical rules and that the network remains secure and reliable.",
      "questions": "1. What is the purpose of this code file?\n- This code file contains a list of consensus-critical validation rules that should be performed by every node in the network for transaction, header, block sections, extension, and block application to state.\n\n2. Can these validation rules be modified or disabled?\n- Yes, some rules that could not lead to money printing and are not enforced by serializers may be disabled later by a miner voting via soft forks, while new rules may also be added at the same time.\n\n3. What are some examples of validation rules for transaction validation?\n- Some examples of validation rules for transaction validation include ensuring that a transaction has at least one input and output, the number of transaction inputs and outputs should not exceed 32767, and the sum of transaction output values should not exceed 9223372036854775807."
    },
    {
      "fileName": "peerManagement.tex",
      "filePath": "papers/yellow/peerManagement.tex",
      "url": "https://github.com/ergoplatform/ergo/papers/yellow/peerManagement.tex",
      "summary": "# Peer Management Protocol\n\nThe `peer management protocol` is a module that manages the peers in a network. A peer is defined as a pair of IP address and port number. The module defines a `peer management structure` that consists of three sets: `good peers`, `banned peers`, and `connected peers`. The `good peers` set contains the peers that are currently considered good and can be connected to. The `banned peers` set contains the peers that are banned from the network due to some misbehavior. The `connected peers` set contains the peers that are currently connected to the network.\n\nThe module also defines a `penalty` structure that contains a description of the misbehavior and a penalty score. The penalty score is a number that defines how bad the misbehavior is. The penalties are divided into four categories: `NonDeliveryPenalty`, `MisbehaviorPenalty`, `SpamPenalty`, and `PermanentPenalty`. The `NonDeliveryPenalty` is applied when a peer fails to deliver a requested modifier in time. The `MisbehaviorPenalty` is applied when a modifier delivered by a peer is found to be invalid. The `SpamPenalty` is applied when a peer delivers a non-requested modifier. The `PermanentPenalty` is applied to peers that deviate from the network protocol.\n\nOnce a penalty is applied, the penalized peer is added to the `penalty book`. The `penalty book` is a mapping of IP addresses to penalty scores and timestamps. Penalties of the same type are not applied to the same peer repeatedly within a safe interval. The safe interval is a delay between penalty applications. Once a peer accumulates a critical penalty score, it is added to the `blacklist`. The `blacklist` is a mapping of IP addresses to timestamps until which the peer is banned.\n\nThe module also defines a `peer discovery protocol` that requests new peers from a source and inserts them into the `good peers` set. The source can be another peer, a trusted central server, or an untrusted communication channel like IRC or Twitter.\n\nOverall, the `peer management protocol` module provides a way to manage the peers in a network by penalizing misbehaving peers and banning them if necessary, discovering new peers, and maintaining a list of good peers that can be connected to.",
      "questions": "1. What is the purpose of the peer management structure and what are its components?\n   \n   The peer management structure is used to manage peers in the network and consists of three sets: good peers (G), banned peers (B), and connected peers (C). Good peers are those that are currently active and trusted, banned peers are those that have been penalized and are temporarily banned, and connected peers are those that are currently connected to the node.\n   \n2. What are the different types of penalties and when are they applied?\n   \n   There are four types of penalties: NonDeliveryPenalty, MisbehaviorPenalty, SpamPenalty, and PermanentPenalty. NonDeliveryPenalty is applied when a peer fails to deliver a requested modifier in time, MisbehaviorPenalty is applied when a delivered modifier is found to be invalid, SpamPenalty is applied when a non-requested modifier is delivered, and PermanentPenalty is applied when a peer deviates from the network protocol. Penalties of the first three types are not applied repeatedly to the same peer within a safe interval.\n   \n3. How does the peer discovery protocol work and what are the possible sources of new peers?\n   \n   The peer discovery protocol requests new peers from a source and adds them to the set of good peers. The source can be another peer, a trusted central server, or an untrusted communication channel such as IRC or Twitter."
    },
    {
      "fileName": "sync.tex",
      "filePath": "papers/yellow/sync.tex",
      "url": "https://github.com/ergoplatform/ergo/papers/yellow/sync.tex",
      "summary": "The code in this file is responsible for the synchronization of blockchain modifiers in the Ergo project. Modifiers can be in one of five states: Unknown, Requested, Received, Held, or Invalid. The goal of the synchronization process is to move modifiers from the Unknown state to the Held state. The success path for a modifier is Unknown -> Requested -> Received -> Held. If something goes wrong, such as the modifier not being delivered, it goes back to the Unknown state (if the node is going to receive it in the future) or to the Invalid state (if the node is not going to receive this modifier anymore).\n\nThe code is split into two parts: protocol and implementation. The protocol part describes the different ways a modifier can move from the Unknown state to the Requested state. One way is through the Inv protocol, where a node sends an Inv message to another node containing a pair of ModifierTypeId and Seq[ModifierId]. The receiving node filters out modifiers that are not in the Unknown state and requests the remaining modifiers from the peer that sent the Inv message. Another way is through headers synchronization, where a node synchronizes its headers chain with the network. The node calculates an ErgoSyncInfo message containing the ids of the last ErgoSyncInfo.MaxBlockIds headers and sends it to peers. The node also sends an ErgoSyncInfo message every time the headers chain is not synced yet, but the number of requested headers is small enough. The third way is through block section synchronization, where a node synchronizes block sections for headers starting at the height of the best full block that are in the Unknown state.\n\nThe implementation part describes how a modifier moves from the Requested state to the Received state and then to the Held state. When a node requests a modifier from another peer, it puts the modifier and corresponding peer to a special map called requested in DeliveryTracker and sends a CheckDelivery message to itself with a deliveryTimeout delay. When the node receives the modifier, it performs initial validation. If the modifier is invalid, the node penalizes the peer and moves the modifier to the Invalid state. If the peer has provided incorrect modifier bytes, the node penalizes the peer and moves the modifier to the Unknown state. If everything is fine, the node sends the modifier to NodeViewHolder (NVH) and sets the modifier to the Received state. When NVH receives new modifiers, it puts them to modifiersCache and applies as many modifiers from the cache as possible. NVH publishes a SyntacticallySuccessfulModifier message for every applied modifier, and when NVS receives this message, it moves the modifier to the Held state.\n\nIn summary, this code is responsible for the synchronization of blockchain modifiers in the Ergo project. It provides a protocol for moving modifiers from the Unknown state to the Requested state and an implementation for moving modifiers from the Requested state to the Received state and then to the Held state. This code is essential for maintaining the integrity of the blockchain and ensuring that all nodes in the network have the same view of the blockchain.",
      "questions": "1. What are the different states that a modifier can be in during the synchronization process?\n- The different states that a modifier can be in during the synchronization process are: Unknown, Requested, Received, Held, and Invalid.\n\n2. How does a node request a modifier from another peer?\n- When a node receives an Inv message from another peer, it filters out modifiers that are not in the Unknown state and requests the remaining modifiers from the peer that sent the Inv message. The modifier then goes into the Requested state.\n\n3. What happens if a modifier is not delivered after a certain number of checks?\n- If a modifier is not delivered after a certain number of checks, the node penalizes the peer (if not requested from a random peer) and stops expecting the modifier. The modifier then goes into the Unknown state."
    },
    {
      "fileName": "tokens.tex",
      "filePath": "papers/yellow/tokens.tex",
      "url": "https://github.com/ergoplatform/ergo/papers/yellow/tokens.tex",
      "summary": "The code provided describes the token emission process in the Ergo project. The purpose of this code is to enable the creation and management of new assets (tokens) on the Ergo blockchain. \n\nThe code implements a conservation law that ensures that the sum of monetary values for transaction inputs equals the corresponding sum for outputs. In addition, one output can hold tokens of multiple kinds, with a maximum of four tokens per output (in addition to the main Ergo token). These tokens are stored in the register R3 as a sequence of $\\{token\\_id: amount\\}$ tuples. \n\nTo create a new asset, an item is appended to the dictionary. To avoid collisions, the $token\\_id$ of the newly created asset must equal the $id$ of the first input of the generating transaction. This ensures the uniqueness of the tokens. Only one output can contain a new asset, and a transaction may create no more than one new asset.\n\nThe validation script ensures that the emission of tokens is controlled and that the sum of tokens in the inputs equals the sum of tokens in the outputs. The script checks that the $id$ of the token being emitted is either present in the inputs or is equal to the $id$ of the first input. This ensures that the emission of tokens is controlled and that no new tokens are created without proper authorization.\n\nOverall, this code enables the creation and management of new assets on the Ergo blockchain. It provides a controlled emission process that ensures the uniqueness and validity of new tokens. The code can be used in various applications that require the creation and management of new assets, such as tokenization of assets, decentralized finance, and gaming. \n\nExample usage of this code would be creating a new asset for a decentralized finance application. The application would use the Ergo blockchain to create a new asset and manage its emission and circulation. The code would ensure that the emission of the new asset is controlled and that the sum of tokens in the inputs equals the sum of tokens in the outputs. This would provide a secure and transparent way to create and manage new assets on the blockchain.",
      "questions": "1. What is the purpose of the code?\n    \n    The purpose of the code is to describe the token emission process in the Ergo project, including the conservation law and the storage of token data in register R3.\n\n2. What is the maximum number of tokens per output?\n\n    The maximum number of tokens per output is 4, in addition to the main Ergo token.\n\n3. How is the controlled emission of tokens organized?\n\n    The controlled emission of tokens may be organized by attaching the emission script to the output which contains newly generated $token\\_id$."
    },
    {
      "fileName": "voting.tex",
      "filePath": "papers/yellow/voting.tex",
      "url": "https://github.com/ergoplatform/ergo/papers/yellow/voting.tex",
      "summary": "The code describes the voting system used in the Ergo blockchain to allow miners to change various parameters on-the-fly. These parameters include instruction costs, computational cost limits, block size limits, storage fee factors, and block versions. There are two types of changes: foundational changes and everyday changes. Foundational changes require more than 90% of miners to vote for the change and last for 32 epochs. Everyday changes require a simple majority. \n\nMiners can vote for two everyday changes and one foundational change per block. To vote \"Yes,\" a miner includes the identifier of the change in the block header. To vote \"No,\" a miner writes a zero value instead of the corresponding byte. \n\nThe code includes a table of parameters that can be changed, their default values, possible steps, and minimum and maximum values. Miners can propose changes by posting an identifier of a vote for a change in the first block of a voting epoch. There are three slots in a block header for changes to propose, with two slots reserved for everyday changes and the third one for proposing a softfork. \n\nSoft-forks happen when a protocol version supported by the network is increased. The protocol version is written into every block header, with the initial value set to 1 during launch. Soft-forks require a proposal to increase the protocol version and put deactivated rules into the extension. Other miners vote within 32 epochs for the proposal. If the proposal is rejected, a new voting may be proposed next epoch after the voting is done. If the proposal is approved, an activation period of 32 epochs starts. Soft-fork data is still written to corresponding extension sections during the activation period, and on activation height. Block version written into extensions is increased from the first block of the activation period, while protocol version in headers is still the same. Protocol version in headers is increased from the activation height.\n\nOverall, this code allows for a flexible and democratic system of parameter changes in the Ergo blockchain. Miners can propose and vote on changes, with different requirements for foundational and everyday changes. Soft-forks can also be proposed and voted on, with an activation period of 32 epochs.",
      "questions": "1. What types of changes can be made via miners voting?\n- Miners can vote for changes such as instruction costs, computational cost limit per block, block size limit, storage fee factor, block version, and more.\n\n2. How are votes for proposals and changes handled?\n- A miner can vote for two everyday changes and one foundational change per block, and to vote \"Yes\" or propose a change, the miner includes the identifier of the change in the block header. To vote \"No\" or abstain from voting, the miner writes a zero value instead of the corresponding byte.\n\n3. How does the soft-fork voting process work?\n- A soft-fork happens when a protocol version supported by the network is increased, and it requires more than 90% of miners to vote for the change. The first block after the activation period should carry soft-fork voting parameters, and a new voting may be started in the next epoch after the activation period."
    }
  ],
  "folders": [
    {
      "folderName": "pow",
      "folderPath": ".autodoc/docs/json/papers/yellow/pow",
      "url": "https://github.com/ergoplatform/ergo/.autodoc/docs/json/papers/yellow/pow",
      "files": [
        {
          "fileName": "ErgoPow.tex",
          "filePath": "papers/yellow/pow/ErgoPow.tex",
          "url": "https://github.com/ergoplatform/ergo/papers/yellow/pow/ErgoPow.tex",
          "summary": "This code describes the Autolykos Proof-of-Work (PoW) algorithm used in the Ergo cryptocurrency. Autolykos has two versions: version 1 (used until block 417,792) and version 2 (used since block 417,792). The main differences between the two versions are:\n\n1. Non-outsourceability is switched off in version 2, as it was found to be unattractive to small miners.\n2. Version 2 binds an efficient solving procedure with a single table of ~2 GB, and the table size grows with time.\n3. The table in version 2 depends only on block height, so there is no penalization for recalculating block candidates for the same height.\n\nThe Autolykos PoW algorithm is memory-hard and non-outsourceable, meaning it requires a significant amount of memory to solve, and outsourcing the puzzle is equivalent to outsourcing a signature. This design aims to maintain decentralization and reduce the advantage of ASIC-equipped miners.\n\nThe code provides two main algorithms: Solution Verification (Alg.~\\ref{alg:verify2}) and Block Mining (Alg.~\\ref{alg:prove2}). The Solution Verification algorithm checks if a given solution is valid, while the Block Mining algorithm is used by miners to find a valid solution for a new block.\n\nThe Autolykos PoW algorithm is efficient in terms of solution size and verification time. The solution consists of two public keys (32 bytes each), a number `d` (up to 32 bytes), and an 8-byte nonce. The verification process requires calculating one `genIndexes` hash, `k` hashes `H`, and performing two exponentiations in the group. The reference Scala implementation allows verifying a block header in 2 milliseconds on an Intel Core i5-7200U, 2.5GHz.",
          "questions": "1. **What is the purpose of the Autolykos Proof-of-Work algorithm?**\n\n   The Autolykos Proof-of-Work algorithm is used in the Ergo cryptocurrency to secure the blockchain by requiring miners to solve a memory-hard, non-outsourceable puzzle. This helps to maintain decentralization and reduce the advantage of ASIC-equipped miners over those using commodity hardware.\n\n2. **What are the main differences between Autolykos version 1 and version 2?**\n\n   Autolykos version 2 introduces several modifications compared to version 1, including turning off non-outsourceability, binding an efficient solving procedure with a single table of ~2 GB, increasing table size (memory requirements) over time, and making the table depend on block height only, which removes penalization for recalculating block candidates for the same height.\n\n3. **How does the Autolykos algorithm ensure memory-hardness?**\n\n   The Autolykos algorithm achieves memory-hardness by requiring miners to store a large list of pre-calculated hashes in memory (2 GB in version 2) during the mining process. While it is possible to recalculate these elements \"on the fly\" and reduce memory requirements, doing so would significantly increase the number of hash function calls, reducing the miner's efficiency and profit."
        },
        {
          "fileName": "compile.sh",
          "filePath": "papers/yellow/pow/compile.sh",
          "url": "https://github.com/ergoplatform/ergo/papers/yellow/pow/compile.sh",
          "summary": "This script is a part of the Ergo project and is responsible for compiling a LaTeX document called ErgoPow.tex into a PDF file called ErgoPow.pdf. The script first checks if the necessary commands, pdflatex and bibtex, are installed on the system by using the command -v option. If either of the commands is not found, the script prints an error message and suggests installing the missing command(s) using apt on Ubuntu. The script then proceeds to remove any existing ErgoPow.pdf file and compiles the LaTeX document using pdflatex and bibtex commands. The pdflatex command generates an auxiliary file called ErgoPow.aux, which is used by bibtex to generate a bibliography file called ErgoPow.bbl. The script then runs pdflatex twice more to incorporate the bibliography into the final PDF file. Finally, the script removes any auxiliary files generated during the compilation process, such as ErgoPow.aux and ErgoPow.log, if the script is run from the same directory as the LaTeX document.\n\nThis script can be used by developers and contributors to the Ergo project to compile the ErgoPow.tex document into a PDF file for distribution or publication. The script ensures that all necessary dependencies are installed and removes any temporary files generated during the compilation process. The script can be run from the command line using the following command:\n\n```\n./compile.sh\n```\n\nAssuming the script is located in the same directory as the ErgoPow.tex file. The resulting ErgoPow.pdf file will also be located in the same directory.",
          "questions": "1. What is the purpose of this script?\n   \n   This script checks if `pdflatex` and `bibtex` are installed and then compiles a LaTeX document called `ErgoPow.tex` to a PDF file called `ErgoPow.pdf`. It also removes some auxiliary files if the script is run from the same directory as the LaTeX files.\n\n2. What operating systems is this script compatible with?\n   \n   This script is designed to work with Unix-like operating systems that use the `sh` shell, such as Linux and macOS.\n\n3. What are some common errors that might occur when running this script?\n   \n   Some common errors that might occur when running this script include `pdflatex` or `bibtex` not being installed, or the LaTeX files not being located in the same directory as the script. The script provides some guidance on how to resolve these errors for Ubuntu users."
        },
        {
          "fileName": "references.bib",
          "filePath": "papers/yellow/pow/references.bib",
          "url": "https://github.com/ergoplatform/ergo/papers/yellow/pow/references.bib",
          "summary": "This file contains a list of references related to the Ergo project, which is a blockchain platform that aims to provide a secure and flexible environment for decentralized applications. The references cover various topics related to blockchain technology, such as proof-of-work algorithms, mining hardware, and security issues.\n\nOne of the main concerns of the Ergo project is to ensure that the platform is resistant to attacks from mining coalitions, which can compromise the security and decentralization of the network. To achieve this goal, the project uses a non-outsourceable scratch-off puzzle, which is a type of proof-of-work algorithm that requires miners to perform a certain amount of computation that cannot be outsourced to other parties. This makes it more difficult for mining coalitions to gain a significant advantage over individual miners, as they would need to invest in specialized hardware or hire a large number of workers to perform the required computations.\n\nThe references in this file provide insights into the various aspects of proof-of-work algorithms and their applications in blockchain technology. For example, the Equihash algorithm is a memory-hard proof-of-work algorithm that is used in the Zcash cryptocurrency to provide ASIC-resistance and prevent mining centralization. The Scrypt algorithm is another memory-hard proof-of-work algorithm that is used in Litecoin and other cryptocurrencies.\n\nThe file also contains references to mining hardware, such as the Autolykos GPU miner, which is a software tool that allows miners to use their graphics cards to mine Ergo coins. The file also mentions the release of Ethereum ASIC miners by Bitmain, which has raised concerns about the centralization of mining power in the Ethereum network.\n\nOverall, this file provides a valuable resource for developers and researchers who are interested in the technical aspects of blockchain technology and proof-of-work algorithms. By studying the references in this file, developers can gain a deeper understanding of the challenges and opportunities of building decentralized applications on the Ergo platform.",
          "questions": "1. What is the purpose of this code file?\n- This code file contains references to various research papers, articles, and online resources related to Bitcoin mining and proof-of-work protocols, which may be useful for developers working on the Ergo platform.\n\n2. What is the significance of the references to ASIC-resistance and memory-hard functions?\n- The references to ASIC-resistance and memory-hard functions suggest that Ergo may be designed to resist the use of specialized hardware (ASICs) for mining, and instead rely on memory-intensive computations that are more resistant to optimization by dedicated hardware.\n\n3. What is the role of Autolykos in Ergo mining, and where can I find its implementation?\n- Autolykos is a GPU miner for the Ergo platform, and its Scala implementation can be found in the Ergo Git repository."
        }
      ],
      "folders": [],
      "summary": "The `pow` folder in the Ergo project contains code and documentation related to the Autolykos Proof-of-Work (PoW) algorithm used in the Ergo cryptocurrency. The Autolykos PoW algorithm is memory-hard and non-outsourceable, which aims to maintain decentralization and reduce the advantage of ASIC-equipped miners.\n\nThe `ErgoPow.tex` file describes the Autolykos PoW algorithm, its two versions, and the main differences between them. It also provides two main algorithms: Solution Verification and Block Mining. The Solution Verification algorithm checks if a given solution is valid, while the Block Mining algorithm is used by miners to find a valid solution for a new block. The Autolykos PoW algorithm is efficient in terms of solution size and verification time.\n\nThe `compile.sh` script is responsible for compiling the `ErgoPow.tex` LaTeX document into a PDF file called `ErgoPow.pdf`. This script can be used by developers and contributors to compile the document for distribution or publication. To use the script, run the following command in the same directory as the `ErgoPow.tex` file:\n\n```bash\n./compile.sh\n```\n\nThe `references.bib` file contains a list of references related to the Ergo project, covering various topics related to blockchain technology, such as proof-of-work algorithms, mining hardware, and security issues. Studying these references can help developers gain a deeper understanding of the challenges and opportunities of building decentralized applications on the Ergo platform.\n\nFor example, developers working on the Ergo project might use the Autolykos PoW algorithm to implement mining functionality in the Ergo blockchain. They can refer to the `ErgoPow.tex` document to understand the algorithm's design and use the Solution Verification and Block Mining algorithms as a basis for their implementation. Additionally, they can use the `compile.sh` script to generate an up-to-date PDF version of the `ErgoPow.tex` document for easy reference or sharing with other team members.\n\nIn summary, the `pow` folder provides valuable resources for developers working on the Ergo project, specifically related to the Autolykos PoW algorithm. By understanding the algorithm and its implications for decentralization and ASIC resistance, developers can contribute to the development of a secure and flexible environment for decentralized applications on the Ergo platform.",
      "questions": ""
    }
  ],
  "summary": "The `yellow` folder in the Ergo project contains code and documentation related to various aspects of the Ergo blockchain, such as the protocol, reference implementation, block structure, token emission, and voting system. It also includes a shell script for compiling LaTeX documents into PDF files.\n\nFor example, the `YellowPaper.tex` file provides a comprehensive description of the Ergo Platform, including its vision, state-oriented design, cryptographic primitives, and modes of operation. Developers can refer to this document to gain a deeper understanding of the Ergo blockchain and its unique features, such as the ErgoTree contract language.\n\nThe `block.tex` file describes the structure and content of the Ergo block, specifically the Header and Extension sections. This information is essential for developers who want to build applications on top of the Ergo blockchain system. By understanding the structure and content of the Ergo block, developers can create more efficient and effective applications that take advantage of the unique features of the Ergo blockchain system.\n\nThe `compile.sh` script can be used by developers to compile LaTeX documents, such as the `YellowPaper.tex` file, into PDF files for easy reference or sharing with other team members. To use the script, run the following command in the same directory as the LaTeX file:\n\n```bash\n./compile.sh\n```\n\nThe `tokens.tex` file describes the token emission process in the Ergo project, enabling the creation and management of new assets (tokens) on the Ergo blockchain. This code can be used in various applications that require the creation and management of new assets, such as tokenization of assets, decentralized finance, and gaming.\n\nThe `voting.tex` file outlines the voting system used in the Ergo blockchain to allow miners to change various parameters on-the-fly. This code allows for a flexible and democratic system of parameter changes in the Ergo blockchain, with different requirements for foundational and everyday changes.\n\nIn summary, the `yellow` folder provides valuable resources for developers working on the Ergo project, covering various aspects of the Ergo blockchain. By understanding the protocol, block structure, token emission, and voting system, developers can contribute to the development of a secure and flexible environment for decentralized applications on the Ergo platform.",
  "questions": ""
}