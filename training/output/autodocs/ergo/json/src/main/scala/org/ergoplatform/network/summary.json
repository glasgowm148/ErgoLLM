{
  "folderName": "network",
  "folderPath": ".autodoc/docs/json/src/main/scala/org/ergoplatform/network",
  "url": "https://github.com/ergoplatform/ergo/.autodoc/docs/json/src/main/scala/org/ergoplatform/network",
  "files": [
    {
      "fileName": "ElementPartitioner.scala",
      "filePath": "src/main/scala/org/ergoplatform/network/ElementPartitioner.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/network/ElementPartitioner.scala",
      "summary": "The `ElementPartitioner` object provides a method called `distribute` that allows for partitioning elements into arbitrarily sized buckets given min/max limits. This method takes in several parameters, including an iterable of buckets to distribute elements into, the maximum number of elements to fetch, the minimum and maximum number of elements to distribute per bucket, and a function that returns elements by type, given a limit. The method returns a map of elements evenly grouped under unique bucket-type keys.\n\nThe `distribute` method first checks if the iterable of buckets is empty and returns an empty map if it is. Otherwise, it calculates the maximum number of elements to fetch based on the minimum and maximum number of elements per bucket and the number of buckets. If the maximum number of elements to fetch is less than or equal to zero, an empty map is returned. Otherwise, the method calls the `fetchMaxElems` function to retrieve the elements and folds over the resulting map to distribute the elements evenly into the buckets.\n\nTo distribute the elements, the method first checks if the number of elements per bucket is less than the minimum number of elements per bucket. If it is, it takes only the first `Math.max(elementsSize / minElementsPerBucket, 1)` buckets, where `elementsSize` is the total number of elements. Otherwise, it uses all of the buckets. It then evenly distributes the elements into the buckets by splitting the elements into groups of equal size and assigning each group to a bucket. If there are any remaining elements, they are distributed one by one to each bucket until there are no more remaining elements.\n\nThis method can be used in the larger project to distribute elements, such as transactions or blocks, to nodes in the network. By partitioning the elements into buckets, the method ensures that each node receives a roughly equal number of elements, which can help balance the load on the network and prevent any one node from becoming overwhelmed. The method can be called with different parameters depending on the specific needs of the network, such as the desired number of elements per bucket or the maximum number of elements to fetch at once. \n\nExample usage:\n\n```\nval buckets = List(\"node1\", \"node2\", \"node3\")\nval maxElements = 100\nval minElementsPerBucket = 5\nval maxElementsPerBucket = 20\n\ndef fetchMaxElems(limit: Int): Map[String, Seq[Int]] = {\n  // implementation that fetches up to `limit` elements per node\n}\n\nval elements = ElementPartitioner.distribute(buckets, maxElements, minElementsPerBucket, maxElementsPerBucket)(fetchMaxElems)\n// elements is a Map[(String, Int), Seq[Int]] where the first element of the tuple is the node and the second element is the type of element\n```",
      "questions": "1. What is the purpose of the `ElementPartitioner` object?\n- The `ElementPartitioner` object allows for partitioning elements into arbitrarily sized buckets given min/max limits.\n\n2. What does the `distribute` method do?\n- The `distribute` method evenly distributes elements under unique bucket-type keys given min/max limits, using a provided function to fetch elements by type.\n\n3. What are the parameters of the `distribute` method?\n- The `distribute` method takes in `buckets` to distribute elements into, `maxElements` as the maximum elements to fetch, `minElementsPerBucket` as the minimum elements to distribute per bucket, `maxElementsPerBucket` as the maximum elements to distribute per bucket, and `fetchMaxElems` as a function that returns elements by type, given a limit."
    },
    {
      "fileName": "ErgoPeerStatus.scala",
      "filePath": "src/main/scala/org/ergoplatform/network/ErgoPeerStatus.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/network/ErgoPeerStatus.scala",
      "summary": "The code defines a container for the status of a peer in the Ergo network. The `ErgoPeerStatus` class has five parameters: `peer`, `status`, `height`, `lastSyncSentTime`, and `lastSyncGetTime`. \n\nThe `peer` parameter is an instance of the `ConnectedPeer` class, which contains information about the peer's public address and operating mode. The `status` parameter is an instance of the `PeerChainStatus` class, which indicates whether the peer is ahead or behind the local blockchain or on a fork. The `height` parameter is an instance of the `Height` class, which represents the height of the peer's blockchain. The `lastSyncSentTime` and `lastSyncGetTime` parameters are optional instances of the `Time` class, which represent the last time the peer was asked to sync and the last time the peer received a sync, respectively.\n\nThe `ErgoPeerStatus` class also has two methods. The `mode` method is a helper method that returns the operating mode of the peer. The `version` method returns the protocol version of the peer.\n\nThe `ErgoPeerStatus` object contains an implicit `jsonEncoder` that encodes an instance of the `ErgoPeerStatus` class as a JSON object. The JSON object contains the following fields: `address`, `version`, `mode`, `status`, and `height`. The `address` field contains the peer's address as a string. The `version` field contains the peer's protocol version as a string. The `mode` field contains the peer's operating mode as a JSON object. The `status` field contains the peer's blockchain status as a string. The `height` field contains the peer's blockchain height as an integer.\n\nThis code is likely used in the larger Ergo project to manage and monitor the status of peers in the network. The `ErgoPeerStatus` class provides a convenient way to store and access information about a peer's status, while the `jsonEncoder` allows this information to be easily serialized and transmitted over the network. This information can be used to make decisions about which peers to connect to and which peers to avoid, as well as to monitor the health and performance of the network as a whole. \n\nExample usage:\n\n```scala\nval peer = ConnectedPeer(...)\nval status = ErgoPeerStatus(peer, PeerChainStatus.OnFork, Height(100), Some(Time.now), None)\nprintln(status.mode) // Some(ModePeerFeature.FullNode)\nprintln(status.version) // Some(Version(1, 3, 0))\nprintln(status.asJson) // {\"address\":\"127.0.0.1:9053\",\"version\":\"1.3.0\",\"mode\":{\"mode\":\"full\"},\"status\":\"OnFork\",\"height\":100}\n```",
      "questions": "1. What is the purpose of the `ErgoPeerStatus` class?\n- The `ErgoPeerStatus` class is a container for status information about another peer, including its blockchain status, height, and last sync times.\n\n2. What is the `mode` field in `ErgoPeerStatus` and how is it determined?\n- The `mode` field is an optional `ModePeerFeature` that represents the operating mode of the peer. It is determined by calling the `mode` method in the companion object, which extracts the `ModePeerFeature` from the peer's `peerSpec` if it exists.\n\n3. What is the purpose of the `jsonEncoder` implicit in the `ErgoPeerStatus` companion object?\n- The `jsonEncoder` implicit is used to encode an `ErgoPeerStatus` object as JSON. It includes fields for the peer's address, version, mode, status, and height."
    },
    {
      "fileName": "ErgoSyncTracker.scala",
      "filePath": "src/main/scala/org/ergoplatform/network/ErgoSyncTracker.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/network/ErgoSyncTracker.scala",
      "summary": "The `ErgoSyncTracker` class is responsible for keeping track of the synchronization status of peers in the Ergo network. It provides data structures and methods to manage the status of peers, find peers with expired status to send sync messages, and update the status of peers based on the sync information received from them.\n\nThe class has a constructor that takes a `NetworkSettings` object as input. It also defines several private constants for managing the synchronization process, such as `MinSyncInterval`, `SyncThreshold`, and `ClearThreshold`.\n\nThe `ErgoSyncTracker` class maintains a mutable map called `statuses` that maps `ConnectedPeer` objects to `ErgoPeerStatus` objects. The `ErgoPeerStatus` class contains information about the synchronization status of a peer, such as its status, height, and last sync time.\n\nThe class provides several methods for managing the synchronization status of peers. The `updateLastSyncGetTime` method updates the last sync time of a peer and returns the time difference between the current time and the previous sync time. The `notSyncedOrOutdated` method checks if a sync message was sent long ago to a peer or not sent at all yet. The `updateStatus` method updates the synchronization status of a peer based on the sync information received from it. It also returns a tuple containing the new peer status and a boolean indicating whether our node should send a sync message to the peer. The `updateLastSyncSentTime` method updates the last sync time of a peer after sending a sync message to it.\n\nThe `ErgoSyncTracker` class also provides several helper methods for managing the synchronization status of peers. The `clearStatus` method clears the status of a peer. The `clearOldStatuses` method clears the status of peers that have not been updated for a long time. The `outdatedPeers` method returns a list of peers that have not been updated for a long time. The `peersToSyncWith` method returns a list of peers to which our node should send a sync signal. It includes outdated peers, if any, otherwise, all the peers with an unknown status plus a random peer with an `Older` status.\n\nThe `ErgoSyncTracker` class is an essential component of the Ergo network. It provides the necessary functionality to manage the synchronization status of peers and ensure that the network is operating correctly. Developers can use this class to build more complex synchronization logic on top of it. For example, they can use it to implement a custom synchronization strategy that takes into account the network topology, latency, and other factors.",
      "questions": "1. What is the purpose of the `ErgoSyncTracker` class?\n- The `ErgoSyncTracker` class is responsible for keeping track of the synchronization status of peers, finding peers with expired status to send sync messages, and updating the status of peers based on received sync messages.\n\n2. What are the meanings of the `MinSyncInterval`, `SyncThreshold`, and `ClearThreshold` variables?\n- `MinSyncInterval` is the minimum amount of time that must pass before sending another sync message to a peer.\n- `SyncThreshold` is the maximum amount of time that can pass before a sync message is considered outdated and a new one should be sent.\n- `ClearThreshold` is the amount of time that must pass before a peer's status is cleared if it has not been updated.\n\n3. What is the purpose of the `peersToSyncWith` method?\n- The `peersToSyncWith` method returns the peers to which this node should send a sync signal, including outdated peers if any, otherwise all the peers with unknown status plus a random peer with `Older` status. It also updates the `lastSyncSentTime` for all returned peers as a side effect."
    },
    {
      "fileName": "FixedSizeApproximateCacheQueue.scala",
      "filePath": "src/main/scala/org/ergoplatform/network/FixedSizeApproximateCacheQueue.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/network/FixedSizeApproximateCacheQueue.scala",
      "summary": "The `ergo` project contains a module called `network`, which includes a Scala file with code that implements an approximate cache queue. The purpose of this code is to provide a fixed-size queue of caches, each representing something like a block. The cache queue is an approximate data structure that can store elements of any type. The cache queue is implemented as a sealed trait called `ApproximateCacheQueueLike`, which defines three methods: `putAll`, `mightContain`, and `approximateElementCount`. \n\nThe `putAll` method takes a sequence of elements and puts them into the underlying caches. It ensures that subsequent invocations of `mightContain` with the elements will always return `true`. The `mightContain` method returns `true` if the element might have been put in these caches, `false` if this is definitely not the case. The `approximateElementCount` method returns an estimate for the total number of distinct elements that have been added to these caches. This approximation is reasonably accurate if approximate caches have not overflowed.\n\nThe `FixedSizeApproximateCacheQueue` case class extends the `ApproximateCacheQueueLike` trait and takes two parameters: `cacheQueueSize` and `cacheQueue`. The `cacheQueueSize` parameter specifies how many caches at maximum to keep in the FIFO queue, and the `cacheQueue` parameter is a FIFO collection of caches. The `FixedSizeApproximateCacheQueue` case class implements the `putAll`, `mightContain`, and `approximateElementCount` methods of the `ApproximateCacheQueueLike` trait. \n\nThe `UnderlyingCache` trait defines two methods: `mightContain` and `approximateElementCount`. The `ConciseCache` case class extends the `UnderlyingCache` trait and implements the `mightContain` and `approximateElementCount` methods. The `ApproxCache` case class also extends the `UnderlyingCache` trait and implements the `mightContain` and `approximateElementCount` methods. The `UnderlyingCache` trait and its two case classes are used to create new caches.\n\nThe `newCache` method of the `UnderlyingCache` object creates a new cache based on the size of the input sequence. If the size of the input sequence is greater than a threshold value, the `ApproxCache` case class is used to create a new cache. Otherwise, the `ConciseCache` case class is used to create a new cache. The `newConciseCache` method of the `ConciseCache` object creates a new `ConciseCache` instance from a sequence of strings. The `newApproxCache` method of the `ApproxCache` object creates a new `ApproxCache` instance from a sequence of strings.\n\nThe `createNewFilter` method of the `ApproxCache` object creates a new Bloom filter with a specified approximate element count and false positive rate. The `empty` method of the `FixedSizeApproximateCacheQueue` object creates an empty `FixedSizeApproximateCacheQueue` instance with a specified cache queue size.\n\nOverall, this code provides a fixed-size queue of caches that can store elements of any type. It uses approximate data structures to provide an estimate of the total number of distinct elements that have been added to the caches. This code can be used in the larger `ergo` project to store and manage blocks of data.",
      "questions": "1. What is the purpose of the `ApproximateCacheQueueLike` trait?\n- The `ApproximateCacheQueueLike` trait is a generic trait that defines methods for an approximate data structure.\n\n2. What is the difference between `ConciseCache` and `ApproxCache`?\n- `ConciseCache` is a cache that stores elements in a set and checks for containment using `contains` method, while `ApproxCache` is a Bloom filter that uses `mightContain` method to check for containment.\n\n3. What is the purpose of the `empty` method in the `FixedSizeApproximateCacheQueue` object?\n- The `empty` method creates an empty `FixedSizeApproximateCacheQueue` with a specified maximum size for the FIFO queue of caches."
    },
    {
      "fileName": "ModePeerFeature.scala",
      "filePath": "src/main/scala/org/ergoplatform/network/ModePeerFeature.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/network/ModePeerFeature.scala",
      "summary": "The `ModePeerFeature` class is a peer feature that stores information on the operating mode of a peer. It contains four fields: `stateType`, which is information on whether the UTXO set is stored (so state type is UTXO/Digest); `verifyingTransactions`, which is a boolean indicating whether the peer is verifying transactions; `popowSuffix`, which is an optional integer indicating whether the peer has bootstrapped via PoPoW suffix, and its length; and `blocksToKeep`, which is an integer indicating how many last full blocks the peer is storing. This class extends the `PeerFeature` trait, which is a marker trait for peer features.\n\nThe `ModePeerFeature` object contains an `apply` method that takes a `NodeConfigurationSettings` object and returns a `ModePeerFeature` object. The `NodeConfigurationSettings` object contains various settings for the node, such as the state type, whether to verify transactions, the PoPoW bootstrap setting, and the number of blocks to keep. The `apply` method creates a `ModePeerFeature` object using these settings.\n\nThe `ModePeerFeature` object also contains a Circe `Encoder` instance for `ModePeerFeature`. This encoder encodes a `ModePeerFeature` object as a JSON object with three fields: `\"state\"`, which is a string representation of the `stateType` field; `\"verifyingTransactions\"`, which is a boolean representation of the `verifyingTransactions` field; and `\"fullBlocksSuffix\"`, which is an integer representation of the `blocksToKeep` field.\n\nThe `ModeFeatureSerializer` object is a Scorex serializer for `ModePeerFeature`. It has a `serialize` method that serializes a `ModePeerFeature` object to a `Writer`, and a `parse` method that deserializes a `ModePeerFeature` object from a `Reader`. The `serialize` method writes the `stateType` field as a byte, the `verifyingTransactions` field as a byte (using a helper method to convert a boolean to a byte), the `popowSuffix` field as an optional integer (using a helper method to write an integer if it is present), and the `blocksToKeep` field as an integer. The `parse` method reads the `stateType` field as a byte, the `verifyingTransactions` field as a byte (using a helper method to convert a byte to a boolean), the `popowSuffix` field as an optional integer (using a helper method to read an integer if it is present), and the `blocksToKeep` field as an integer.\n\nOverall, this code provides a way to store and serialize/deserialize information about the operating mode of a peer. This information can be used by other parts of the `ergo` project to make decisions about how to interact with the peer. For example, if a peer is not verifying transactions, it may not be trusted to provide accurate information about the state of the blockchain.",
      "questions": "1. What is the purpose of the `ModePeerFeature` class?\n- The `ModePeerFeature` class is a peer feature that stores information on the operating mode of the peer, such as whether it is verifying transactions and how many last full blocks it is storing.\n\n2. What is the purpose of the `ModeFeatureSerializer` object?\n- The `ModeFeatureSerializer` object is a serializer for the `ModePeerFeature` class that allows it to be serialized and deserialized.\n\n3. What is the purpose of the `jsonEncoder` implicit value in the `ModePeerFeature` object?\n- The `jsonEncoder` implicit value is an encoder that allows a `ModePeerFeature` instance to be encoded as JSON."
    },
    {
      "fileName": "PeerFilteringRule.scala",
      "filePath": "src/main/scala/org/ergoplatform/network/PeerFilteringRule.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/network/PeerFilteringRule.scala",
      "summary": "The code defines a set of rules for filtering peers in the Ergo network based on their version and other properties. The `PeerFilteringRule` trait is an abstract component that describes the action of choosing peers from available ones based on their version. It has three methods: `condition(version: Version)` that returns whether a peer of a given version should be selected, `condition(peer: ConnectedPeer)` that returns whether a peer should be selected based on its version, and `filter(peers: Iterable[ConnectedPeer])` that selects peers satisfying the condition from the provided ones.\n\nThe code defines four objects that extend the `PeerFilteringRule` trait. The `DigestModeFilter` object selects peers that have a version greater than or equal to 4.0.22, which allows for downloading ADProofs that are too big in block at 667614. The `BrokenModifiersFilter` object filters out peers of version 4.0.17 or 4.0.18, which are delivering broken block sections. The `SyncV2Filter` object selects peers that have a version greater than or equal to 4.0.16, which indicates that the peer is supporting sync V2. Finally, the `BlockSectionsDownloadFilter` object is a combination of `DigestModeFilter` and `BrokenModifiersFilter` and is used to download block sections. It takes a `StateType` parameter that specifies the node's state type and selects peers based on the condition of either `DigestModeFilter` or `BrokenModifiersFilter`, depending on the state type.\n\nThese filtering rules are used in the larger Ergo project to select peers for various purposes, such as downloading blocks and ADProofs, syncing with other nodes, and more. For example, to select peers that support sync V2, one can use the `SyncV2Filter` object as follows:\n\n```\nval peers: Iterable[ConnectedPeer] = // get connected peers\nval syncV2Peers = SyncV2Filter.filter(peers)\n```\n\nThis will return an iterable of peers that have a version greater than or equal to 4.0.16 and support sync V2.",
      "questions": "1. What is the purpose of the `PeerFilteringRule` trait and its methods?\n- The `PeerFilteringRule` trait is an abstract component that describes an action of choosing peers from available ones based on peer version (and other properties). Its methods are used to define conditions for selecting peers based on their version.\n\n2. What is the purpose of the `DigestModeFilter` and `BrokenModifiersFilter` objects?\n- The `DigestModeFilter` object is used to filter out peers that do not support downloading ADProofs that are too big in block at 667614. The `BrokenModifiersFilter` object is used to filter out peers of version 4.0.17 or 4.0.18 that are delivering broken block sections.\n\n3. What is the purpose of the `BlockSectionsDownloadFilter` and `SyncV2Filter` classes?\n- The `BlockSectionsDownloadFilter` class is used to filter peers to download block sections, combining `DigestModeFilter` and `BrokenModifiersFilter`. Its `condition` method checks the state type and applies the appropriate filter. The `SyncV2Filter` class is used to filter peers that support sync V2. Its `condition` method checks the peer version and returns true if it is greater than or equal to version 4.0.16."
    }
  ],
  "folders": [],
  "summary": "The code in this folder is responsible for managing various aspects of the Ergo network, such as partitioning elements, tracking peer status, and filtering peers based on specific conditions. It provides classes and methods for distributing elements into buckets, maintaining synchronization status of peers, and selecting peers based on their version and other properties.\n\nFor example, the `ElementPartitioner` object provides a method called `distribute` that allows for partitioning elements into arbitrarily sized buckets given min/max limits. This method can be used in the larger project to distribute elements, such as transactions or blocks, to nodes in the network, ensuring that each node receives a roughly equal number of elements and helping balance the load on the network.\n\nThe `ErgoPeerStatus` class is a container for the status of a peer in the Ergo network. It provides a convenient way to store and access information about a peer's status, while the `jsonEncoder` allows this information to be easily serialized and transmitted over the network. This information can be used to make decisions about which peers to connect to and which peers to avoid, as well as to monitor the health and performance of the network as a whole.\n\nThe `ErgoSyncTracker` class is responsible for keeping track of the synchronization status of peers in the Ergo network. It provides data structures and methods to manage the status of peers, find peers with expired status to send sync messages, and update the status of peers based on the sync information received from them. This class is an essential component of the Ergo network, providing the necessary functionality to manage the synchronization status of peers and ensure that the network is operating correctly.\n\nThe `FixedSizeApproximateCacheQueue` case class provides a fixed-size queue of caches that can store elements of any type. It uses approximate data structures to provide an estimate of the total number of distinct elements that have been added to the caches. This code can be used in the larger Ergo project to store and manage blocks of data.\n\nThe `ModePeerFeature` class is a peer feature that stores information on the operating mode of a peer. This information can be used by other parts of the Ergo project to make decisions about how to interact with the peer. For example, if a peer is not verifying transactions, it may not be trusted to provide accurate information about the state of the blockchain.\n\nThe `PeerFilteringRule` trait and its implementations define a set of rules for filtering peers in the Ergo network based on their version and other properties. These filtering rules are used in the larger Ergo project to select peers for various purposes, such as downloading blocks and ADProofs, syncing with other nodes, and more.",
  "questions": ""
}