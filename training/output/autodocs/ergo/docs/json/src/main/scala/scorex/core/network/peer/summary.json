{
  "folderName": "peer",
  "folderPath": ".autodoc/docs/json/src/main/scala/scorex/core/network/peer",
  "url": "https://github.com/ergoplatform/ergo/.autodoc/docs/json/src/main/scala/scorex/core/network/peer",
  "files": [
    {
      "fileName": "LocalAddressPeerFeature.scala",
      "filePath": "src/main/scala/scorex/core/network/peer/LocalAddressPeerFeature.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/scorex/core/network/peer/LocalAddressPeerFeature.scala",
      "summary": "The code defines a PeerFeature for the ergo project that is used to handle connections from/to local or loopback addresses. The LocalAddressPeerFeature class takes an InetSocketAddress as a parameter and extends the PeerFeature trait. It also defines a serializer for the LocalAddressPeerFeature class.\n\nThe LocalAddressPeerFeatureSerializer object extends the ScorexSerializer trait and provides methods for serializing and parsing LocalAddressPeerFeature objects. The serialize method takes a LocalAddressPeerFeature object and a Writer object and writes the address and port of the object to the writer. The parse method takes a Reader object and returns a LocalAddressPeerFeature object by reading the address and port from the reader.\n\nThis PeerFeature is useful for handling connections to and from local or loopback addresses, which are typically used for testing and development purposes. It can be used in the larger project to ensure that connections to and from these addresses are handled correctly and securely.\n\nExample usage:\n\n```\nval address = new InetSocketAddress(InetAddress.getLocalHost, 8080)\nval feature = LocalAddressPeerFeature(address)\nval serializer = LocalAddressPeerFeatureSerializer\n\n// Serialize the feature\nval writer = new Writer()\nserializer.serialize(feature, writer)\nval bytes = writer.toBytes\n\n// Parse the feature from bytes\nval reader = new Reader(bytes)\nval parsedFeature = serializer.parse(reader)\n\nassert(parsedFeature == feature)\n```",
      "questions": "1. What is the purpose of the `LocalAddressPeerFeature` class?\n- The `LocalAddressPeerFeature` class is a peer feature required for handling connections from/to local or loopback address.\n\n2. What is the `LocalAddressPeerFeatureSerializer` object used for?\n- The `LocalAddressPeerFeatureSerializer` object is a Scorex serializer for the `LocalAddressPeerFeature` class.\n\n3. What is the significance of the `featureId` field in the `LocalAddressPeerFeature` class?\n- The `featureId` field in the `LocalAddressPeerFeature` class is the ID of the peer feature, which is defined in the `PeerFeatureDescriptors` object in the `org.ergoplatform.settings` package."
    },
    {
      "fileName": "PeerDatabase.scala",
      "filePath": "src/main/scala/scorex/core/network/peer/PeerDatabase.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/scorex/core/network/peer/PeerDatabase.scala",
      "summary": "The `PeerDatabase` class is a component of the Ergo project that provides an in-memory implementation of a peer database. The class is responsible for managing the list of known peers, blacklisting peers that misbehave, and penalizing peers that violate network rules. \n\nThe class has several private variables that store information about peers, including a map of known peers, a map of blacklisted peers, and a map of penalized peers. The class also has a reference to a persistent key-value store that is used to store peer information. \n\nThe `PeerDatabase` class provides several public methods that allow other components of the Ergo project to interact with the peer database. These methods include:\n\n- `get(peer: InetSocketAddress): Option[PeerInfo]`: Returns the `PeerInfo` object for a given peer address.\n- `addOrUpdateKnownPeer(peerInfo: PeerInfo): Unit`: Adds or updates the `PeerInfo` object for a known peer.\n- `addToBlacklist(socketAddress: InetSocketAddress, penaltyType: PenaltyType): Unit`: Adds a peer to the blacklist for a specified duration.\n- `removeFromBlacklist(address: InetAddress): Unit`: Removes a peer from the blacklist.\n- `remove(address: InetSocketAddress): Unit`: Removes a peer from the list of known peers.\n- `knownPeers: Map[InetSocketAddress, PeerInfo]`: Returns a map of all known peers.\n- `blacklistedPeers: Seq[InetAddress]`: Returns a sequence of all blacklisted peers.\n- `isEmpty: Boolean`: Returns `true` if the list of known peers is empty, `false` otherwise.\n- `isBlacklisted(address: InetAddress): Boolean`: Returns `true` if a peer is blacklisted, `false` otherwise.\n- `isBlacklisted(address: InetSocketAddress): Boolean`: Returns `true` if a peer is blacklisted, `false` otherwise.\n- `penalize(socketAddress: InetSocketAddress, penaltyType: PenaltyType): Boolean`: Registers a new penalty in the penalty book and returns `true` if the penalty threshold is reached, `false` otherwise.\n- `penaltyScore(address: InetAddress): Int`: Returns the currently accumulated penalty score for a given address.\n- `penaltyScore(socketAddress: InetSocketAddress): Int`: Returns the currently accumulated penalty score for a given socket address.\n\nThe `PeerDatabase` class also has several private methods that are used internally. These methods include:\n\n- `serialize(obj: Object): Array[Byte]`: Serializes an object using the standard Java serializer.\n- `deserialize(bytes: Array[Byte]): Object`: Deserializes an object using the standard Java serializer.\n- `loadPeers: Try[Map[InetSocketAddress, PeerInfo]]`: Loads peers from the persistent key-value store.\n- `checkBanned(address: InetAddress, bannedTill: Long): Boolean`: Checks if a peer is still blacklisted.\n- `penaltyScore(penaltyType: PenaltyType): Int`: Returns the penalty score for a given penalty type.\n- `penaltyDuration(penalty: PenaltyType): Long`: Returns the duration of a penalty for a given penalty type.\n\nOverall, the `PeerDatabase` class provides an important component of the Ergo project that manages the list of known peers, blacklists misbehaving peers, and penalizes peers that violate network rules.",
      "questions": "1. What is the purpose of the `PeerDatabase` class?\n- The `PeerDatabase` class is an in-memory peer database implementation that supports temporal blacklisting.\n\n2. How does the `PeerDatabase` class handle serialization and deserialization of objects?\n- The `PeerDatabase` class uses standard Java serializer to serialize and deserialize objects.\n\n3. What is the penalty book in the `PeerDatabase` class used for?\n- The penalty book in the `PeerDatabase` class is used to keep track of penalized peers' accumulated penalty score and last penalty timestamp."
    },
    {
      "fileName": "PeerInfo.scala",
      "filePath": "src/main/scala/scorex/core/network/peer/PeerInfo.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/scorex/core/network/peer/PeerInfo.scala",
      "summary": "The `PeerInfo` object and its associated serializer `PeerInfoSerializer` are part of the `ergo` project's networking module. The purpose of `PeerInfo` is to store information about a peer that is connected to the node, such as the peer's `PeerSpec` (which contains general information about the peer), the timestamp of the last handshake with the peer, the type of connection (incoming or outgoing), and the timestamp of the last time the peer was seen active. The `PeersStatus` case class is used to store information about the status of the P2P layer, including the timestamp of the last incoming message and the current network time.\n\nThe `PeerInfoSerializer` is used to serialize and deserialize `PeerInfo` objects. When serializing a `PeerInfo` object, the serializer writes the last handshake timestamp, the connection type (if any), and the `PeerSpec` object to a `Writer`. When deserializing a `PeerInfo` object, the serializer reads the last handshake timestamp, the connection type (if any), and the `PeerSpec` object from a `Reader`.\n\nThe `fromAddress` method in the `PeerInfo` object is used to create a `PeerInfo` object when only the peer's address is known (e.g. from a configuration file or API). It creates a `PeerSpec` object with default values for the other fields and returns a `PeerInfo` object with the `PeerSpec`, a last handshake timestamp of 0, and no connection type.\n\nOverall, the `PeerInfo` object and `PeerInfoSerializer` are important components of the `ergo` project's networking module, as they allow the node to store and manage information about connected peers. The `PeersStatus` case class provides additional information about the status of the P2P layer. These objects can be used in conjunction with other networking components to facilitate communication between nodes in the network.",
      "questions": "1. What is the purpose of the `PeerInfo` and `PeersStatus` case classes?\n- `PeerInfo` stores information about a peer to be stored in a peer database, including general information about the peer, the timestamp of the last handshake, the type of connection established to this peer (if any), and the timestamp when the peer was last seen active.\n- `PeersStatus` stores information about the P2P layer status, including the timestamp of the last received message from any peer and the current network time.\n\n2. What is the purpose of the `PeerInfoSerializer` object?\n- `PeerInfoSerializer` is a serializer for the `PeerInfo` case class, which serializes and deserializes `PeerInfo` objects to and from bytes.\n\n3. What is the purpose of the `fromAddress` method in the `PeerInfo` case class?\n- The `fromAddress` method creates a `PeerInfo` object from an `InetSocketAddress` when other fields are unknown (e.g. when the information is obtained from a configuration file or an API). It creates a `PeerSpec` object with default values and uses it to create the `PeerInfo` object with a timestamp of 0 for the last handshake and no connection type."
    },
    {
      "fileName": "PeerManager.scala",
      "filePath": "src/main/scala/scorex/core/network/peer/PeerManager.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/scorex/core/network/peer/PeerManager.scala",
      "summary": "The `PeerManager` class is responsible for managing peers connected to the network. It is a singleton class that handles the addition, removal, and blacklisting of peers. The class also chooses a random peer to connect to. \n\nThe `PeerManager` class receives messages from other actors in the system. The `peersManagement` method handles messages related to peer management, such as adding or removing peers, confirming connections, and penalizing peers. The `apiInterface` method handles messages related to the API, such as getting all peers or getting blacklisted peers. \n\nThe `PeerManager` class uses a `PeerDatabase` object to store information about known peers. If the database is empty, the class fills it with peers from the configuration file. The class also checks if a peer is the same as the current node by comparing IP addresses. \n\nThe `PeerManager` class has several nested classes and objects that define the messages it can receive. These messages include `ConfirmConnection`, `ConnectionConfirmed`, `ConnectionDenied`, `Penalize`, `AddOrUpdatePeer`, `AddPeerIfEmpty`, `RemovePeer`, `GetAllPeers`, `GetBlacklistedPeers`, `SeenPeers`, `RandomPeerExcluding`, and `Blacklisted`. \n\nThe `SeenPeers` message is used to choose a random set of peers to recommend to a peer asking for more peers. The `RandomPeerExcluding` message is used to choose a random peer to connect to, excluding a set of excluded peers. \n\nOverall, the `PeerManager` class is an important component of the `ergo` project, as it manages the peers connected to the network and facilitates communication between nodes.",
      "questions": "1. What is the purpose of the `PeerManager` class?\n- The `PeerManager` class manages connected peers and chooses a random peer to connect to.\n\n2. What is the `isSelf` method used for?\n- The `isSelf` method is used to determine if a given peer's address is the same as the address of the current node.\n\n3. What is the purpose of the `RandomPeerExcluding` case class?\n- The `RandomPeerExcluding` case class is used to choose a random peer to connect to, excluding a list of specified peers."
    },
    {
      "fileName": "PenaltyType.scala",
      "filePath": "src/main/scala/scorex/core/network/peer/PenaltyType.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/scorex/core/network/peer/PenaltyType.scala",
      "summary": "The code defines a trait called `PenaltyType` which describes different types of misbehavior that a network participant can exhibit. Each type of misbehavior has a `penaltyScore` associated with it, which is a number that defines how bad the misbehavior is. Additionally, each type of misbehavior has a flag called `isPermanent` which defines whether the penalty for that misbehavior is permanent or not.\n\nThe `PenaltyType` trait is sealed, which means that all implementations of this trait must be defined in this file. The `object PenaltyType` contains four case objects that extend the `PenaltyType` trait. These case objects define the different types of misbehavior that a network participant can exhibit and their associated `penaltyScore` values.\n\nThe `NonDeliveryPenalty` case object has a `penaltyScore` of 2, which means that it is a relatively minor misbehavior. The `MisbehaviorPenalty` case object has a `penaltyScore` of 10, which means that it is a more serious misbehavior. The `SpamPenalty` case object has a `penaltyScore` of 25, which means that it is a very serious misbehavior. Finally, the `PermanentPenalty` case object has a `penaltyScore` of 1000000000 and its `isPermanent` flag is set to true, which means that it is a permanent and very severe penalty.\n\nThis code is likely used in the larger project to define the different types of penalties that can be imposed on network participants who exhibit different types of misbehavior. For example, if a network participant fails to deliver a message, they may be penalized with a `NonDeliveryPenalty`. If a network participant engages in spamming behavior, they may be penalized with a `SpamPenalty`. These penalties can be used to incentivize network participants to behave properly and discourage them from engaging in misbehavior.\n\nExample usage:\n```\nval penalty: PenaltyType = NonDeliveryPenalty\nprintln(penalty.penaltyScore) // Output: 2\nprintln(penalty.isPermanent) // Output: false\n```",
      "questions": "1. What is the purpose of the `PenaltyType` trait and its subclasses?\n- The `PenaltyType` trait describes different types of network participant misbehavior and their associated penalty scores and permanence flags.\n\n2. What is the purpose of the `isPermanent` flag in the `PenaltyType` trait?\n- The `isPermanent` flag indicates whether a penalty for a particular type of misbehavior is permanent or not.\n\n3. What is the penalty score for the `PermanentPenalty` subclass?\n- The penalty score for the `PermanentPenalty` subclass is set to a very high value of 1000000000, indicating that this type of misbehavior results in a severe penalty. Additionally, the `isPermanent` flag is set to true for this subclass."
    },
    {
      "fileName": "RestApiUrlPeerFeature.scala",
      "filePath": "src/main/scala/scorex/core/network/peer/RestApiUrlPeerFeature.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/scorex/core/network/peer/RestApiUrlPeerFeature.scala",
      "summary": "The code defines a PeerFeature for the ergo project, which represents a feature that a peer in the network may have. Specifically, this PeerFeature is for a rest-api URL that a peer may have enabled, which needs to be passed to/from other peers. The purpose of this feature is to allow peers to communicate with each other over the rest-api, which is a publicly accessible URL of a node that exposes its rest-api in a firewall.\n\nThe code defines a case class called RestApiUrlPeerFeature, which takes a single parameter, the restApiUrl. This case class extends the PeerFeature trait, which defines the basic functionality of a peer feature. The case class also defines a serializer, which is used to serialize and deserialize RestApiUrlPeerFeature objects.\n\nThe RestApiUrlPeerFeatureSerializer object defines the serialization and deserialization methods for the RestApiUrlPeerFeature case class. The serialize method takes a RestApiUrlPeerFeature object and a Writer object, and writes the restApiUrl to the Writer object. The parse method takes a Reader object and returns a RestApiUrlPeerFeature object.\n\nThis code is used in the larger ergo project to allow peers to communicate with each other over the rest-api. Peers that have the rest-api URL enabled can use this feature to communicate with other peers that also have the feature enabled. This feature is important for the ergo project because it allows peers to share information and work together more effectively. \n\nExample usage:\n\n```scala\nimport java.net.URL\nimport scorex.core.network.peer.RestApiUrlPeerFeature\n\n// create a RestApiUrlPeerFeature object\nval restApiUrl = new URL(\"http://example.com/api\")\nval restApiFeature = RestApiUrlPeerFeature(restApiUrl)\n\n// serialize the object\nval writer = new java.io.ByteArrayOutputStream()\nRestApiUrlPeerFeatureSerializer.serialize(restApiFeature, writer)\nval bytes = writer.toByteArray()\n\n// deserialize the object\nval reader = new java.io.ByteArrayInputStream(bytes)\nval deserializedFeature = RestApiUrlPeerFeatureSerializer.parse(reader)\n```",
      "questions": "1. What is the purpose of the `RestApiUrlPeerFeature` class?\n- The `RestApiUrlPeerFeature` class represents a feature that a peer may have, which is a publicly accessible URL of a node that exposes a REST API in a firewall.\n\n2. What is the `RestApiUrlPeerFeatureSerializer` object used for?\n- The `RestApiUrlPeerFeatureSerializer` object is used to serialize and deserialize instances of the `RestApiUrlPeerFeature` class.\n\n3. What is the `PeerFeatureDescriptors.RestApiUrlFeatureId` used for?\n- The `PeerFeatureDescriptors.RestApiUrlFeatureId` is used as the feature ID for instances of the `RestApiUrlPeerFeature` class."
    },
    {
      "fileName": "SessionIdPeerFeature.scala",
      "filePath": "src/main/scala/scorex/core/network/peer/SessionIdPeerFeature.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/scorex/core/network/peer/SessionIdPeerFeature.scala",
      "summary": "The code defines a peer feature for the Ergo platform's network module. The purpose of this feature is to improve the reliability of detecting connections to and from the self node and other networks. The feature is implemented as a case class called `SessionIdPeerFeature` that takes two parameters: `networkMagic` and `sessionId`. `networkMagic` is an array of bytes that is taken from the settings, while `sessionId` is a randomly generated 64-bit session identifier.\n\nThe `SessionIdPeerFeature` class extends the `PeerFeature` trait, which is a common interface for all peer features in the Ergo platform. The `PeerFeature` trait defines two abstract types: `M` and `Id`. `M` is the type of the peer feature itself, while `Id` is a unique identifier for the feature. In this case, the `Id` is defined as `PeerFeatureDescriptors.SessionIdPeerFeatureId`, which is a predefined value in the `PeerFeatureDescriptors` object.\n\nThe `SessionIdPeerFeature` class also defines a `serializer` method that returns an instance of the `SessionIdPeerFeatureSerializer` object. This object extends the `ScorexSerializer` trait, which is a common interface for all serializers in the Ergo platform. The `ScorexSerializer` trait defines two abstract methods: `serialize` and `parse`. `serialize` takes an object of the type being serialized and a `Writer` object, and writes the serialized data to the `Writer`. `parse` takes a `Reader` object and returns an object of the type being deserialized. In this case, the `serialize` method writes the `networkMagic` and `sessionId` fields to the `Writer`, while the `parse` method reads these fields from the `Reader` and returns a new instance of the `SessionIdPeerFeature` class.\n\nOverall, this code provides a way to add a peer feature to the Ergo platform's network module that improves the reliability of detecting connections to and from the self node and other networks. This feature can be used in the larger project to ensure that network connections are established and maintained correctly. An example of how this feature might be used in the larger project is to detect and handle connections from other networks that may be attempting to interfere with the Ergo platform's network.",
      "questions": "1. What is the purpose of this code?\n   - This code defines a peer feature for the Ergo platform that allows for more reliable detection of connections to and from other networks.\n2. What is the significance of the `networkMagic` and `sessionId` parameters?\n   - `networkMagic` is a byte array used to identify the network, while `sessionId` is a randomly generated 64-bit identifier used to distinguish between different sessions.\n3. What is the role of the `SessionIdPeerFeatureSerializer` object?\n   - `SessionIdPeerFeatureSerializer` is a serializer object that defines how to serialize and parse `SessionIdPeerFeature` objects."
    }
  ],
  "folders": [],
  "summary": "The code in this folder is responsible for managing the peers in the Ergo network, handling their features, and maintaining a database of known, blacklisted, and penalized peers. The folder contains several classes and objects that work together to achieve this functionality.\n\n`LocalAddressPeerFeature.scala` defines a `PeerFeature` for handling connections from/to local or loopback addresses, typically used for testing and development purposes. It includes a serializer for the `LocalAddressPeerFeature` class, which can be used to serialize and deserialize the feature. Example usage can be found in the provided code snippet.\n\n`PeerDatabase.scala` provides an in-memory implementation of a peer database, managing the list of known peers, blacklisting misbehaving peers, and penalizing peers that violate network rules. It exposes several public methods for interacting with the peer database, such as adding or updating known peers, adding peers to the blacklist, and checking if a peer is blacklisted.\n\n`PeerInfo.scala` stores information about a connected peer, such as their `PeerSpec`, last handshake timestamp, connection type, and last seen timestamp. It also includes a serializer, `PeerInfoSerializer`, for serializing and deserializing `PeerInfo` objects. The `PeersStatus` case class provides additional information about the status of the P2P layer.\n\n`PeerManager.scala` is responsible for managing peers connected to the network, handling the addition, removal, and blacklisting of peers, and choosing a random peer to connect to. It receives messages from other actors in the system and uses a `PeerDatabase` object to store information about known peers. The class also defines several nested classes and objects for handling different types of messages related to peer management and API interactions.\n\n`PenaltyType.scala` defines a trait for different types of misbehavior that a network participant can exhibit, along with their associated penalty scores and a flag indicating whether the penalty is permanent. This code can be used to impose penalties on network participants who exhibit misbehavior, incentivizing proper behavior and discouraging misbehavior.\n\n`RestApiUrlPeerFeature.scala` defines a `PeerFeature` for a rest-api URL that a peer may have enabled, allowing peers to communicate with each other over the rest-api. It includes a serializer for the `RestApiUrlPeerFeature` class, which can be used to serialize and deserialize the feature.\n\n`SessionIdPeerFeature.scala` defines a peer feature for improving the reliability of detecting connections to and from the self node and other networks. It includes a serializer for the `SessionIdPeerFeature` class, which can be used to serialize and deserialize the feature.\n\nOverall, the code in this folder plays a crucial role in managing the peers in the Ergo network, ensuring that connections are established and maintained correctly, and penalizing misbehaving peers.",
  "questions": ""
}