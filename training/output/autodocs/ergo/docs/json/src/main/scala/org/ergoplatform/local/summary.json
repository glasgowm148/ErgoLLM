{
  "folderName": "local",
  "folderPath": ".autodoc/docs/json/src/main/scala/org/ergoplatform/local",
  "url": "https://github.com/ergoplatform/ergo/.autodoc/docs/json/src/main/scala/org/ergoplatform/local",
  "files": [
    {
      "fileName": "CleanupWorker.scala",
      "filePath": "src/main/scala/org/ergoplatform/local/CleanupWorker.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/local/CleanupWorker.scala",
      "summary": "The `CleanupWorker` class is responsible for performing mempool transactions re-validation. It is called on a new block coming and validation results are sent directly to `NodeViewHolder`. The purpose of this class is to validate transactions from the mempool for some specified amount of time and update the valid transactions and invalidated transaction ids. \n\nThe `CleanupWorker` class has two main methods: `preStart()` and `receive()`. The `preStart()` method is called when the actor is started and logs a message that the cleanup worker has started. The `receive()` method is the main method that receives messages and performs the cleanup. It has two cases: `RunCleanup` and `Any`. The `RunCleanup` case runs the cleanup and sends a message to the sender that the cleanup is done. The `Any` case logs a warning message if a non-expected signal comes.\n\nThe `CleanupWorker` class has two private methods: `runCleanup()` and `validatePool()`. The `runCleanup()` method takes a `validator` and a `mempool` as input and validates the mempool transactions. It then sends the validated and invalidated transactions to the `NodeViewHolder`. The `validatePool()` method takes a `validator` and a `mempool` as input and validates transactions from the mempool for some specified amount of time. It returns updated valid transactions and invalidated transaction ids.\n\nThe `CleanupWorker` class has two constants: `CostLimit` and `TimeLimit`. `CostLimit` is the limit for the total cost of transactions to be re-checked and is hard-coded for now. `TimeLimit` is the time limit after which a transaction can be re-checked.\n\nThe `CleanupWorker` class has an object `CleanupWorker` that has a case class `RunCleanup`. `RunCleanup` is a command to run (partial) memory pool cleanup and takes a `validator` and a `mempool` as input.\n\nOverall, the `CleanupWorker` class is an important part of the ergo project as it ensures that mempool transactions are validated and updated correctly. It can be used in the larger project to ensure that the blockchain is secure and transactions are validated correctly.",
      "questions": "1. What is the purpose of the `CleanupWorker` class?\n- The `CleanupWorker` class performs mempool transactions re-validation and sends validation results directly to `NodeViewHolder`.\n\n2. What are the limits for the transactions to be re-checked?\n- The limit for the total cost of transactions to be re-checked is hard-coded to 7000000, and a transaction can be re-checked only after the time limit specified in the node settings' `mempoolCleanupDuration` parameter.\n\n3. What is the purpose of the `validatePool` method?\n- The `validatePool` method validates transactions from the mempool for a specified amount of time and returns updated valid transactions and invalidated transaction IDs. It also takes into account other transactions from the pool to provide the possibility to validate transactions that are spending off-chain outputs."
    },
    {
      "fileName": "ErgoStatsCollector.scala",
      "filePath": "src/main/scala/org/ergoplatform/local/ErgoStatsCollector.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/local/ErgoStatsCollector.scala",
      "summary": "The `ErgoStatsCollector` class is responsible for collecting and providing statistics about the Ergo node to API requests. It subscribes to `NodeViewHolderEvents` and collects information about the node's state, history, and mempool to provide fast responses to API requests. \n\nThe `ErgoStatsCollector` class takes four parameters: `readersHolder`, `networkController`, `syncTracker`, and `settings`. `readersHolder` is an `ActorRef` that holds the readers for the node. `networkController` is an `ActorRef` that controls the node's network. `syncTracker` is an `ErgoSyncTracker` that tracks the node's synchronization status. `settings` is an `ErgoSettings` object that contains the node's settings.\n\nThe `ErgoStatsCollector` class has a `receive` method that handles messages sent to it. It handles messages related to connected peers, peers status, node information, mempool changes, state changes, history changes, and semantically successful modifications. It also has an `init` method that initializes the `nodeInfo` object with information about the node's state, history, and parameters.\n\nThe `ErgoStatsCollector` class has a nested `NodeInfo` case class that contains information about the node. This case class is used to respond to `/info` API requests. The `NodeInfo` case class contains information about the node's name, version, network type, unconfirmed transaction count, peer count, state root, state type, state version, mining status, best header, headers score, best full block, full blocks score, maximum peer height, launch time, last incoming message time, genesis block ID, network parameters, EIP-27 support, REST API URL, and extra indexing.\n\nThe `ErgoStatsCollector` class is used in the larger Ergo project to provide statistics about the node to API requests. This information can be used by developers and users to monitor the node's status and performance. For example, the unconfirmed transaction count can be used to monitor the node's mempool, while the best header and best full block information can be used to monitor the node's synchronization status.",
      "questions": "1. What is the purpose of the `ErgoStatsCollector` class?\n- The `ErgoStatsCollector` class subscribes to `NodeViewHolderEvents` and collects them to provide fast response to API requests.\n\n2. What data does the `NodeInfo` case class contain?\n- The `NodeInfo` case class contains information such as the node's name, version, network type, number of unconfirmed transactions in the mempool, number of peers the node is connected with, current UTXO set digest, state type, id of a block UTXO set digest is taken from, whether the node is mining, best header ID, cumulative difficulty of best headers-chain, best full-block id, cumulative difficulty of best full blocks chain, maximum block height of connected peers, when the node was launched, when the node received last p2p message, header id of genesis block, array with network parameters at the moment, whether EIP-27 locked in, publicly accessible url of node which exposes restApi in firewall, and whether the node has additional indexing enabled.\n\n3. What does the `init` method do?\n- The `init` method initializes the `nodeInfo` variable with information such as the best full block, best header, headers score, full blocks score, genesis block ID, state root, state version, and parameters."
    },
    {
      "fileName": "MempoolAuditor.scala",
      "filePath": "src/main/scala/org/ergoplatform/local/MempoolAuditor.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/local/MempoolAuditor.scala",
      "summary": "The `MempoolAuditor` class is responsible for controlling the mempool cleanup workflow in the Ergo platform. It watches NodeView events and delegates the mempool cleanup task to the `CleanupWorker` when needed. \n\nThe class extends the `Actor` trait and overrides some of its methods such as `postRestart`, `postStop`, and `receive`. It also defines a `supervisorStrategy` that specifies how the actor should behave in case of exceptions. \n\nThe `MempoolAuditor` class has three main states: `awaiting`, `working`, and `initiateCleanup`. The `awaiting` state is the initial state, where the actor waits for a `RecheckMempool` message that contains the `UtxoStateReader` and `ErgoMemPoolReader` objects. Once it receives the message, it stores the objects in `stateReaderOpt` and `poolReaderOpt` variables and initiates the cleanup process by calling the `initiateCleanup` method. \n\nThe `initiateCleanup` method creates a new `CleanupWorker` actor and sends it a `RunCleanup` message with the `UtxoStateReader` and `ErgoMemPoolReader` objects. It then switches the actor's state to `working`. \n\nThe `working` state is where the actor waits for the `CleanupDone` message from the `CleanupWorker`. Once it receives the message, it rebroadcasts the transactions in the mempool by calling the `rebroadcastTransactions` method and switches the actor's state back to `awaiting`. \n\nThe `rebroadcastTransactions` method rebroadcasts the transactions in the mempool by creating a new `Message` object and sending it to the network controller. It first selects a random subset of transactions from the mempool and then checks if all the inputs of each transaction are in the UTXO set. If they are, it rebroadcasts the transaction; otherwise, it logs a warning message. \n\nOverall, the `MempoolAuditor` class plays a crucial role in maintaining the integrity of the Ergo platform by ensuring that the mempool is cleaned up periodically and that all transactions in the mempool are valid.",
      "questions": "1. What is the purpose of this code and how does it fit into the overall ergo project?\n- This code controls the mempool cleanup workflow and delegates the task to a CleanupWorker. It is part of the local package in the ergo project.\n\n2. What is the supervisor strategy used in this code and how does it handle exceptions?\n- The supervisor strategy used is OneForOneStrategy, which applies to the worker actor. It allows for a maximum of 5 retries within a 1-minute time range. It stops the worker actor in case of ActorKilledException or DeathPactException, and restarts it in case of other exceptions.\n\n3. What is the purpose of the rebroadcastTransactions() method and how does it work?\n- The rebroadcastTransactions() method rebroadcasts unconfirmed transactions in the mempool. It selects a random subset of transactions to rebroadcast, and checks if all the inputs of each transaction are in the UTXO set. If they are, the transaction is rebroadcasted, otherwise it is not."
    },
    {
      "fileName": "NipopowVerifier.scala",
      "filePath": "src/main/scala/org/ergoplatform/local/NipopowVerifier.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/local/NipopowVerifier.scala",
      "summary": "The `NipopowVerifier` class is a verifier for PoPoW (Proof of Proof of Work) proofs in the Ergo platform. Its purpose is to process multiple proofs and determine the best (sub)chain rooted at the specified genesis block. \n\nThe class takes in a `genesisId` parameter, which is the block id of the genesis block. It has a `bestProof` variable that is an `Option` of `NipopowProof`, which represents the best proof processed so far. It also has a `bestChain` method that returns the headers chain of the best proof, or an empty sequence if there is no best proof yet.\n\nThe `process` method takes in a new `NipopowProof` and checks if its headers chain starts with the `genesisId` and if it is better than the current `bestProof`. If both conditions are met, the `bestProof` variable is updated with the new proof.\n\nThis class can be used in the larger project to verify PoPoW proofs and determine the best chain in the Ergo platform. For example, it can be used in a consensus algorithm to determine the valid chain in the network. \n\nHere is an example of how to use the `NipopowVerifier` class:\n\n```scala\nimport org.ergoplatform.local.NipopowVerifier\nimport org.ergoplatform.modifiers.history.header.Header\nimport org.ergoplatform.modifiers.history.popow.NipopowProof\nimport scorex.util.ModifierId\n\n// create a new verifier with the genesis block id\nval verifier = new NipopowVerifier(genesisBlockId)\n\n// create a new proof\nval proof = new NipopowProof(headersChain)\n\n// process the proof\nverifier.process(proof)\n\n// get the best chain\nval bestChain: Seq[Header] = verifier.bestChain\n``` \n\nIn this example, a new `NipopowVerifier` is created with the `genesisBlockId`. A new `NipopowProof` is created with a `headersChain`. The proof is then processed by the verifier using the `process` method. Finally, the best chain is obtained using the `bestChain` method.",
      "questions": "1. What is a PoPoW proof and how does it relate to the Ergo platform?\n- A PoPoW proof is a type of proof used in the Ergo platform, and this code implements a verifier for it.\n2. What is the purpose of the `bestChain` method?\n- The `bestChain` method returns the best (sub)chain rooted at the specified genesis block, as determined by the `bestProof` variable.\n3. How does the `process` method determine whether a new proof is better than the current `bestProof`?\n- The `process` method checks if the new proof's headers chain starts with the genesis block and if it is better than the current `bestProof`. If both conditions are met, the new proof becomes the new `bestProof`."
    }
  ],
  "folders": [],
  "summary": "The `.autodoc/docs/json/src/main/scala/org/ergoplatform/local` folder contains classes responsible for managing the mempool, collecting node statistics, and verifying PoPoW proofs in the Ergo platform.\n\n`CleanupWorker.scala` is responsible for re-validating mempool transactions when a new block arrives. It validates transactions for a specified amount of time and updates the valid transactions and invalidated transaction ids. This class ensures that mempool transactions are validated and updated correctly, contributing to the security and validity of the blockchain.\n\nExample usage:\n\n```scala\nval cleanupWorker = context.actorOf(CleanupWorker.props)\ncleanupWorker ! CleanupWorker.RunCleanup(validator, mempool)\n```\n\n`ErgoStatsCollector.scala` collects and provides statistics about the Ergo node to API requests. It subscribes to `NodeViewHolderEvents` and gathers information about the node's state, history, and mempool. This class is useful for developers and users to monitor the node's status and performance.\n\nExample usage:\n\n```scala\nval statsCollector = context.actorOf(ErgoStatsCollector.props(readersHolder, networkController, syncTracker, settings))\n```\n\n`MempoolAuditor.scala` controls the mempool cleanup workflow by watching NodeView events and delegating the cleanup task to the `CleanupWorker`. It ensures that the mempool is cleaned up periodically and that all transactions in the mempool are valid.\n\nExample usage:\n\n```scala\nval mempoolAuditor = context.actorOf(MempoolAuditor.props)\nmempoolAuditor ! MempoolAuditor.RecheckMempool(stateReader, mempoolReader)\n```\n\n`NipopowVerifier.scala` verifies PoPoW proofs and determines the best (sub)chain rooted at the specified genesis block. It can be used in a consensus algorithm to determine the valid chain in the network.\n\nExample usage:\n\n```scala\nval verifier = new NipopowVerifier(genesisBlockId)\nval proof = new NipopowProof(headersChain)\nverifier.process(proof)\nval bestChain: Seq[Header] = verifier.bestChain\n```\n\nThese classes work together to maintain the integrity of the Ergo platform by ensuring that mempool transactions are validated, node statistics are collected, and PoPoW proofs are verified. They can be used in the larger project to ensure that the blockchain is secure, transactions are validated correctly, and the node's status and performance are monitored.",
  "questions": ""
}