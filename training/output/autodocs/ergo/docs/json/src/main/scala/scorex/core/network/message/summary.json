{
  "folderName": "message",
  "folderPath": ".autodoc/docs/json/src/main/scala/scorex/core/network/message",
  "url": "https://github.com/ergoplatform/ergo/.autodoc/docs/json/src/main/scala/scorex/core/network/message",
  "files": [
    {
      "fileName": "BasicMessagesRepo.scala",
      "filePath": "src/main/scala/scorex/core/network/message/BasicMessagesRepo.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/scorex/core/network/message/BasicMessagesRepo.scala",
      "summary": "The code defines several message types used in the communication between nodes in the Ergo blockchain network. \n\nThe `ModifiersData` case class is a wrapper for block sections of the same type. It is used to send multiple block sections at once over the wire. The `InvData` case class transmits one or more inventories of objects known to the transmitting peer. It can be sent unsolicited to announce new transactions or blocks, or it can be sent in reply to a `SyncInfo` message. \n\nThe `SyncInfoMessageSpec` class is responsible for requesting an `Inv` message that provides modifier ids required by the sender to synchronize their blockchain with the recipient. It allows a peer which has been disconnected or started for the first time to get the data it needs to request the blocks it hasn't seen. \n\nThe `RequestModifierSpec` object requests one or more modifiers from another node. The objects are requested by an inventory, which the requesting node typically received previously by way of an `Inv` message. \n\nThe `ModifiersSpec` object is a reply to a `RequestModifier` message which requested these modifiers. It serializes and parses the data to be sent over the network. \n\nThe `GetPeersSpec` object requests a `Peers` message from the receiving node, preferably one with lots of `PeerSpec` of other receiving nodes. The transmitting node can use those `PeerSpec` addresses to quickly update its database of available nodes rather than waiting for unsolicited `Peers` messages to arrive over time. \n\nThe `PeersSpec` object is a reply to a `GetPeer` message and relays connection information about peers on the network. \n\nThe `HandshakeSerializer` object provides information about the transmitting node to the receiving node at the beginning of a connection. Until both peers have exchanged `Handshake` messages, no other messages will be accepted. \n\nOverall, these message types are used to facilitate communication between nodes in the Ergo blockchain network. They allow nodes to request and receive data from each other, as well as exchange information about available peers.",
      "questions": "1. What is the purpose of the `ModifiersData` and `InvData` case classes?\n- `ModifiersData` is a wrapper for block sections of the same type, used to send multiple block sections at once over the wire. It contains a `NetworkObjectTypeId` value and a map of `ModifierId` keys and byte array values. \n- `InvData` is used to transmit one or more inventories of objects known to the transmitting peer. It contains a `NetworkObjectTypeId` value and a sequence of `ModifierId` values.\n\n2. What is the purpose of the `SyncInfoMessageSpec` class?\n- The `SyncInfoMessageSpec` class is used to request an `Inv` message that provides modifier ids required by the sender to synchronize their blockchain with the recipient. It allows a peer which has been disconnected or started for the first time to get the data it needs to request the blocks it hasn't seen.\n\n3. What is the purpose of the `HandshakeSerializer` object?\n- The `HandshakeSerializer` object provides information about the transmitting node to the receiving node at the beginning of a connection. Until both peers have exchanged `Handshake` messages, no other messages will be accepted. It serializes a `Handshake` instance into a byte writer and parses a `Handshake` instance from a byte reader."
    },
    {
      "fileName": "Message.scala",
      "filePath": "src/main/scala/scorex/core/network/message/Message.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/scorex/core/network/message/Message.scala",
      "summary": "The `Message` class is a wrapper for network messages in the `ergo` project. It can be used to wrap messages that come from external peers or messages that are generated locally. The class takes three parameters: `spec`, `input`, and `source`. `spec` is the message specification, `input` is the message being wrapped, and `source` is the source peer if the message is from outside.\n\nThe `Message` class has three lazy values: `dataBytes`, `data`, and `dataLength`. `dataBytes` is the message data bytes, which are either in byte-array form (if the message is from outside) or structured data (if the message is formed locally). `data` is the structured message content, which is either parsed from the byte-array form (if the message is from outside) or the original structured data (if the message is formed locally). `dataLength` is the length of the message data bytes.\n\nThe `Message` class also has a `messageLength` method, which returns the serialized message length in bytes. The length is calculated based on the length of the message data bytes. If the length of the message data bytes is greater than zero, the length of the serialized message is the sum of the header length, the checksum length, and the length of the message data bytes. Otherwise, the length of the serialized message is just the header length.\n\nThe `Message` object defines three constants: `MagicLength`, `ChecksumLength`, and `HeaderLength`. `MagicLength` is the length of the magic bytes that identify the message. `ChecksumLength` is the length of the checksum bytes that are used to verify the integrity of the message. `HeaderLength` is the length of the message header, which is the sum of the magic length and five bytes that encode the message code and the length of the message data.\n\nOverall, the `Message` class provides a convenient way to wrap network messages in the `ergo` project and to calculate the length of the serialized messages. It can be used in conjunction with other classes and methods in the project to implement the network communication protocol.",
      "questions": "1. What is the purpose of the `Message` class?\n- The `Message` class is a wrapper for a network message, whether it comes from an external peer or is generated locally.\n\n2. What is the purpose of the `data` and `dataBytes` properties?\n- The `data` property returns the structured message content, while the `dataBytes` property returns the message data bytes.\n \n3. What is the purpose of the `messageLength` method?\n- The `messageLength` method returns the serialized message length in bytes, which is calculated based on the length of the message data and the header and checksum lengths."
    },
    {
      "fileName": "MessageSerializer.scala",
      "filePath": "src/main/scala/scorex/core/network/message/MessageSerializer.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/scorex/core/network/message/MessageSerializer.scala",
      "summary": "The `MessageSerializer` class is responsible for serializing and deserializing messages in the ergo project. It takes in two parameters: `specs` and `magicBytes`. `specs` is a sequence of `MessageSpec` objects, which define the structure of the messages that can be serialized and deserialized. `magicBytes` is an array of bytes that is used to identify the network that the message is coming from or going to.\n\nThe `serialize` method takes a `Message` object and returns a `ByteString` representation of it. It first creates a `ByteString` builder and adds the `magicBytes`, `messageCode`, and `dataLength` to it. If the `dataLength` is greater than 0, it calculates the checksum of the `dataBytes` using the Blake2b256 hash function and adds it to the builder along with the `dataBytes`. Finally, it returns the result of the builder.\n\nThe `deserialize` method takes a `ByteString` and an optional `ConnectedPeer` object and returns a `Try` of an optional `Message` object. It first checks if the `ByteString` is long enough to contain the header of the message. If it is not, it returns `None`. Otherwise, it extracts the `magicBytes`, `messageCode`, and `dataLength` from the `ByteString`. If the `dataLength` is negative, it throws a `MaliciousBehaviorException`. If the `ByteString` is not long enough to contain the entire message, it returns `None`. If the `magicBytes` do not match the expected `magicBytes`, it throws a `MaliciousBehaviorException`. If there is no `MessageSpec` object for the `messageCode`, it throws an `Error`. If the `dataLength` is greater than 0, it extracts the checksum and data from the `ByteString`, calculates the checksum of the data using the Blake2b256 hash function, and compares it to the extracted checksum. If they do not match, it throws a `MaliciousBehaviorException`. Finally, it returns a `Some` of a `Message` object with the `MessageSpec`, `msgData`, and `sourceOpt` fields.\n\nOverall, the `MessageSerializer` class is an important part of the ergo project's networking layer. It allows messages to be sent and received between nodes in a secure and reliable manner. Here is an example of how it might be used:\n\n```\nval serializer = new MessageSerializer(Seq(MyMessageSpec), Array(0x12, 0x34, 0x56, 0x78))\nval message = MyMessage(data)\nval serialized = serializer.serialize(message)\nval deserialized = serializer.deserialize(serialized, Some(peer))\n```",
      "questions": "1. What is the purpose of the `MessageSerializer` class?\n- The `MessageSerializer` class is responsible for serializing and deserializing messages for the `ergo` project's network communication.\n\n2. What is the significance of the `magicBytes` parameter?\n- The `magicBytes` parameter is used to identify the network that a message belongs to. It is used to ensure that messages are only received from the expected network.\n\n3. What is the purpose of the `MaliciousBehaviorException` and when is it thrown?\n- The `MaliciousBehaviorException` is thrown when a peer is attempting to cause a buffer overflow or break the parsing of a message. It is also thrown when a peer reports an incorrect checksum for a message."
    },
    {
      "fileName": "MessageSpec.scala",
      "filePath": "src/main/scala/scorex/core/network/message/MessageSpec.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/scorex/core/network/message/MessageSpec.scala",
      "summary": "The code above defines two traits that are used for implementing peer-to-peer (p2p) messages in the network of the ergo project. The `MessageSpec` trait is a base trait that defines the common properties of all p2p messages in the network. It extends the `ScorexSerializer` trait, which is used for serializing and deserializing objects. The `MessageSpec` trait has three properties: `protocolVersion`, `messageCode`, and `messageName`. \n\nThe `protocolVersion` property is a `Version` object that represents the p2p protocol version in which this message type first appeared. The `messageCode` property is a `Message.MessageCode` object that identifies what message type is contained in the payload. The `messageName` property is a string that represents the name of this message type, which is used for debugging purposes.\n\nThe `MessageSpecV1` trait extends the `MessageSpec` trait and is used for defining p2p messages that were implemented since the beginning of the project. It sets the `protocolVersion` property to the initial version of the project.\n\nThese traits are used for defining the structure of p2p messages in the ergo project. Developers can create their own message types by extending these traits and defining their own properties. For example, a developer can create a new message type called `MyMessage` by defining a new class that extends the `MessageSpec` trait and sets the `messageCode` and `messageName` properties to appropriate values:\n\n```\ncase class MyMessage(content: String) extends MessageSpec[String] {\n  override val protocolVersion: Version = Version.initial\n  override val messageCode: Message.MessageCode = MessageCodes.MyMessageCode\n  override val messageName: String = \"MyMessage\"\n}\n```\n\nThis code defines a new message type called `MyMessage` that contains a string payload. The `messageCode` property is set to a custom message code called `MyMessageCode`, which is defined elsewhere in the project. The `messageName` property is set to \"MyMessage\". This new message type can be used in the ergo network by serializing and deserializing it using the `ScorexSerializer` trait.",
      "questions": "1. What is the purpose of this code?\n   - This code defines traits for app p2p messages in the network and specifies their protocol version, message code, and name.\n\n2. What is the difference between `MessageSpec` and `MessageSpecV1`?\n   - `MessageSpec` is a base trait for all app p2p messages, while `MessageSpecV1` is a trait for messages that were implemented since the beginning. `MessageSpecV1` inherits from `MessageSpec` and sets the protocol version to `Version.initial`.\n\n3. What is the `ScorexSerializer` trait that `MessageSpec` extends?\n   - `ScorexSerializer` is a trait that defines serialization and deserialization methods for objects. By extending this trait, `MessageSpec` specifies how its content should be serialized and deserialized."
    }
  ],
  "folders": [],
  "summary": "The code in this folder is responsible for handling network messages in the Ergo blockchain project. It defines several message types and their serialization and deserialization logic, which are crucial for communication between nodes in the network.\n\n`BasicMessagesRepo.scala` defines various message types used in the Ergo network, such as `ModifiersData`, `InvData`, `SyncInfoMessageSpec`, `RequestModifierSpec`, `ModifiersSpec`, `GetPeersSpec`, `PeersSpec`, and `HandshakeSerializer`. These message types facilitate communication between nodes, allowing them to request and receive data from each other and exchange information about available peers.\n\n`Message.scala` provides a wrapper for network messages in the Ergo project. It can be used to wrap messages from external peers or locally generated messages. The class calculates the length of the serialized messages and provides a convenient way to work with network messages in conjunction with other classes and methods in the project.\n\n`MessageSerializer.scala` is responsible for serializing and deserializing messages in the Ergo project. It takes a sequence of `MessageSpec` objects and an array of bytes (magicBytes) to identify the network. The `serialize` method converts a `Message` object into a `ByteString` representation, while the `deserialize` method takes a `ByteString` and returns a `Try` of an optional `Message` object. This class is an essential part of the Ergo project's networking layer, allowing secure and reliable communication between nodes.\n\n`MessageSpec.scala` defines two traits, `MessageSpec` and `MessageSpecV1`, used for implementing peer-to-peer (p2p) messages in the Ergo network. Developers can create their own message types by extending these traits and defining their own properties.\n\nHere's an example of how the code in this folder might be used:\n\n```scala\nval serializer = new MessageSerializer(Seq(MyMessageSpec), Array(0x12, 0x34, 0x56, 0x78))\nval message = MyMessage(data)\nval serialized = serializer.serialize(message)\nval deserialized = serializer.deserialize(serialized, Some(peer))\n```\n\nIn this example, a `MessageSerializer` is created with a custom `MyMessageSpec` and magicBytes. A `MyMessage` instance is created with some data, serialized using the `serialize` method, and then deserialized using the `deserialize` method.\n\nOverall, the code in this folder plays a vital role in the Ergo project by defining the structure and serialization logic of network messages, enabling efficient and secure communication between nodes in the Ergo blockchain network.",
  "questions": ""
}