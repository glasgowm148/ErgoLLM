{
  "folderName": "popow",
  "folderPath": ".autodoc/docs/json/src/main/scala/org/ergoplatform/modifiers/history/popow",
  "url": "https://github.com/ergoplatform/ergo/.autodoc/docs/json/src/main/scala/org/ergoplatform/modifiers/history/popow",
  "files": [
    {
      "fileName": "NipopowAlgos.scala",
      "filePath": "src/main/scala/org/ergoplatform/modifiers/history/popow/NipopowAlgos.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/modifiers/history/popow/NipopowAlgos.scala",
      "summary": "The code in this file is part of the NiPoPoW (Non-Interactive Proofs of Proof-of-Work) implementation for the Ergo platform. NiPoPoW is a protocol that allows lightweight clients to verify the validity of a blockchain without downloading the entire chain. It is based on the KMZ17 and KLS16 papers.\n\nThe `NipopowAlgos` class provides various utility methods for working with the NiPoPoW protocol. Some of the key methods include:\n\n- `updateInterlinks`: Computes the interlinks vector for a header next to the given `prevHeader`.\n- `maxLevelOf`: Computes the max level (Âµ) of the given header, which is used to determine the importance of a block in the NiPoPoW proof.\n- `bestArg`: Computes the best score of a given chain, which is used to find the best argument for a proof.\n- `lowestCommonAncestor`: Finds the last common header (branching point) between two chains.\n- `prove`: Computes the NiPoPoW proof for a given chain according to the specified `PoPowParams`.\n\nThe `NipopowAlgos` class can be used in the larger project to create and verify NiPoPoW proofs. For example, a lightweight client can use the `prove` method to create a NiPoPoW proof for a specific chain and then send it to another client for verification. The other client can then use the `lowestCommonAncestor` and `bestArg` methods to verify the proof without downloading the entire chain.\n\nHere's an example of how to create a NiPoPoW proof for a chain:\n\n```scala\nval nipopowAlgos = new NipopowAlgos(powScheme)\nval chain: Seq[PoPowHeader] = ... // A sequence of PoPowHeader objects representing the chain\nval params = PoPowParams(m = 3, k = 6) // NiPoPoW proof parameters\nval proofTry: Try[NipopowProof] = nipopowAlgos.prove(chain)(params)\n```\n\nAnd here's an example of how to verify a NiPoPoW proof:\n\n```scala\nval proof: NipopowProof = ... // A NipopowProof object to verify\nval lca = nipopowAlgos.lowestCommonAncestor(proof.prefix, anotherChain)\nval bestArgScore = nipopowAlgos.bestArg(proof.prefix)(proof.m)\n// Verify the proof by checking the LCA and best argument score\n```",
      "questions": "1. **Question**: What is the purpose of the `NipopowAlgos` class and how does it relate to the NiPoPoW protocol?\n   **Answer**: The `NipopowAlgos` class provides a set of utilities for working with the NiPoPoW (Non-Interactive Proofs of Proof-of-Work) protocol. It is based on the KMZ17 and KLS16 papers and provides methods for computing interlinks, max level of a header, best score of a chain, lowest common ancestor, and NiPoPoW proofs for a given chain or history reader.\n\n2. **Question**: How does the `prove` method work and what are its input parameters and expected output?\n   **Answer**: The `prove` method computes a NiPoPoW proof for a given chain or history reader according to the provided `PoPowParams` (m and k values). It takes either a sequence of `PoPowHeader` objects (chain) or an `ErgoHistoryReader` object (history reader) along with an optional `headerIdOpt` parameter. The method returns a `Try[NipopowProof]` object, which contains the computed NiPoPoW proof if successful.\n\n3. **Question**: What is the purpose of the `PoPowParams` case class and how is it used in the `NipopowAlgos` class?\n   **Answer**: The `PoPowParams` case class represents the NiPoPoW proof parameters from the KMZ17 paper, specifically the minimal superchain length (m) and the suffix length (k). It is used as an input parameter for the `prove` method in the `NipopowAlgos` class to compute NiPoPoW proofs according to the specified parameters."
    },
    {
      "fileName": "NipopowProof.scala",
      "filePath": "src/main/scala/org/ergoplatform/modifiers/history/popow/NipopowProof.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/modifiers/history/popow/NipopowProof.scala",
      "summary": "The code defines a structure called `NipopowProof` that represents a Non-Interactive Proof of Proof-of-Work (NiPoPoW) as a persistent modifier. The NiPoPoW is a proof system that allows a prover to convince a verifier that a certain block is included in the longest chain of a blockchain without revealing the entire chain. The `NipopowProof` structure contains the security parameters `m` and `k`, which are used to determine the minimum superchain length and suffix length, respectively. It also contains the prefix headers, suffix head, and suffix tail, which are used to construct the NiPoPoW proof.\n\nThe `NipopowProof` structure has several methods that are used to serialize and deserialize the proof, as well as to check its validity. The `serializer` method returns a `ScorexSerializer` that is used to serialize the `NipopowProof` structure. The `headersChain` method returns a sequence of all the headers in the proof, while the `prefixHeaders` and `suffixHeaders` methods return the prefix and suffix headers, respectively. The `chainOfLevel` method returns a sequence of headers that have a level greater than or equal to the specified level.\n\nThe `isBetterThan` method compares two `NipopowProof` structures and returns true if the current proof is better than the other proof. The `isValid` method checks if the proof is valid by verifying the consistency of the heights and connections of the headers in the proof. The `hasValidHeights` method checks if the heights of the headers are consistent, while the `hasValidConnections` method checks if the connections between adjacent blocks are valid. The `hasValidProofs` method checks the interlink proofs of the blocks in the proof.\n\nThe `NipopowProof` structure also contains an `Encoder` and a `Decoder` that are used to encode and decode the proof in JSON format. The `NipopowProofSerializer` class is used to serialize and deserialize the `NipopowProof` structure.\n\nOverall, the `NipopowProof` structure is an important component of the `ergo` project, as it provides a way to construct and verify NiPoPoW proofs, which are used to improve the security and scalability of the blockchain.",
      "questions": "1. What is the purpose of the `NipopowProof` class and what are its main components?\n- The `NipopowProof` class represents a NiPoPow proof as a persistent modifier and consists of security parameters `m` and `k`, proof prefix headers, the first header of the suffix, and the tail of the proof suffix headers.\n2. What is the `isBetterThan` method used for and how does it work?\n- The `isBetterThan` method is used to compare two PoPoW proofs and determine if the current proof is better than the other. It checks if both proofs are valid, finds the lowest common ancestor of the header chains, and compares the best arguments of the diverging chains using the `popowAlgos` algorithm.\n3. What are the `hasValidHeights`, `hasValidConnections`, and `hasValidProofs` methods used for?\n- The `hasValidHeights` method checks if the heights of the header-chain are consistent, meaning that for any two blocks b1 and b2, if b1 precedes b2 then b1's height should be smaller.\n- The `hasValidConnections` method checks the connections of the blocks in the proof and ensures that adjacent blocks are linked either via interlink or parent block id.\n- The `hasValidProofs` method checks the interlink proofs of the blocks in the proof."
    },
    {
      "fileName": "PoPowHeader.scala",
      "filePath": "src/main/scala/org/ergoplatform/modifiers/history/popow/PoPowHeader.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/modifiers/history/popow/PoPowHeader.scala",
      "summary": "The `PoPowHeader` class and its associated objects and methods are part of the Ergo blockchain project. This class represents a block header along with unpacked interlinks. Interlinks are stored in reverse order, with the first element always being the genesis header, followed by the level of the lowest target met, and so on. This class is not used in the consensus protocol.\n\nThe `PoPowHeader` class has several methods. The `checkInterlinksProof` method validates the interlinks merkle root against the provided proof. The `fromBlock` method creates a `PoPowHeader` from a given block. The `id` method returns the header's ID. The `height` method returns the header's height.\n\nThe `PoPowHeader` class also has several implicit encoders and decoders for JSON serialization. The `interlinksEncoder` encodes a sequence of modifier IDs as a JSON array of strings. The `batchMerkleProofEncoder` encodes a `BatchMerkleProof` object as a JSON object with two fields: `indices` and `proofs`. The `batchMerkleProofDecoder` decodes a JSON object with the same fields as the `batchMerkleProofEncoder` into a `BatchMerkleProof` object. The `popowHeaderJsonEncoder` encodes a `PoPowHeader` object as a JSON object with three fields: `header`, `interlinks`, and `interlinksProof`. The `popowHeaderJsonDecoder` decodes a JSON object with the same fields as the `popowHeaderJsonEncoder` into a `PoPowHeader` object.\n\nThe `PoPowHeaderSerializer` object is a binary serializer for `PoPowHeader`. It serializes a `PoPowHeader` object into a byte array and deserializes a byte array into a `PoPowHeader` object. It uses the `HeaderSerializer` and `BatchMerkleProofSerializer` objects to serialize and deserialize the header and interlinks proof, respectively.\n\nOverall, the `PoPowHeader` class and its associated objects and methods provide functionality for working with block headers and interlinks in the Ergo blockchain project. They allow for validation of interlinks proofs, creation of `PoPowHeader` objects from blocks, and serialization and deserialization of `PoPowHeader` objects.",
      "questions": "1. What is the purpose of the `PoPowHeader` class and how is it used in the project?\n- The `PoPowHeader` class represents a block header with unpacked interlinks, stored in reverse order. It is not used in the consensus protocol. It is used to create a `PoPowHeader` from a given block and to validate interlinks merkle root against provided proof.\n2. What is the `checkInterlinksProof` method used for and how does it work?\n- The `checkInterlinksProof` method is used to validate interlinks merkle root against provided proof. It first packs the interlinks into a byte array using `NipopowAlgos.packInterlinks`, then generates a merkle tree from the byte array using `merkleTree`, and finally checks if the provided proof is valid against the root hash of the merkle tree.\n3. What are the `interlinksEncoder` and `batchMerkleProofEncoder` used for and how are they implemented?\n- The `interlinksEncoder` is used to encode a sequence of `ModifierId` into a JSON array of strings. It maps each `ModifierId` to its string representation and then encodes the resulting sequence as a JSON array using `asJson`.\n- The `batchMerkleProofEncoder` is used to encode a `BatchMerkleProof[Digest32]` into a JSON object. It first encodes the indices and digests of the proof as a sequence of JSON objects, and then encodes the proofs and sides of the proof as another sequence of JSON objects. Finally, it combines the two sequences into a JSON object with two fields, \"indices\" and \"proofs\", and encodes the resulting object using `asJson`."
    }
  ],
  "folders": [],
  "summary": "The code in this folder is part of the Ergo platform's implementation of the NiPoPoW (Non-Interactive Proofs of Proof-of-Work) protocol, which allows lightweight clients to verify the validity of a blockchain without downloading the entire chain. The main components in this folder are the `NipopowAlgos` class, the `NipopowProof` structure, and the `PoPowHeader` class.\n\nThe `NipopowAlgos` class provides utility methods for working with the NiPoPoW protocol, such as computing interlinks, max level, best score, lowest common ancestor, and generating NiPoPoW proofs. These methods can be used in the larger project to create and verify NiPoPoW proofs, allowing lightweight clients to efficiently verify the blockchain.\n\n```scala\nval nipopowAlgos = new NipopowAlgos(powScheme)\nval chain: Seq[PoPowHeader] = ... // A sequence of PoPowHeader objects representing the chain\nval params = PoPowParams(m = 3, k = 6) // NiPoPoW proof parameters\nval proofTry: Try[NipopowProof] = nipopowAlgos.prove(chain)(params)\n```\n\nThe `NipopowProof` structure represents a NiPoPoW proof and contains methods for serialization, deserialization, and validity checking. It is used to construct and verify NiPoPoW proofs, improving the security and scalability of the blockchain.\n\n```scala\nval proof: NipopowProof = ... // A NipopowProof object to verify\nval lca = nipopowAlgos.lowestCommonAncestor(proof.prefix, anotherChain)\nval bestArgScore = nipopowAlgos.bestArg(proof.prefix)(proof.m)\n// Verify the proof by checking the LCA and best argument score\n```\n\nThe `PoPowHeader` class represents a block header with unpacked interlinks and provides methods for validation, creation, and serialization. It is not used in the consensus protocol but is essential for working with block headers and interlinks in the Ergo blockchain project.\n\nIn summary, the code in this folder is crucial for implementing the NiPoPoW protocol in the Ergo platform, allowing lightweight clients to efficiently verify the blockchain without downloading the entire chain. The `NipopowAlgos` class, `NipopowProof` structure, and `PoPowHeader` class provide the necessary functionality for creating, verifying, and working with NiPoPoW proofs and block headers with interlinks.",
  "questions": ""
}