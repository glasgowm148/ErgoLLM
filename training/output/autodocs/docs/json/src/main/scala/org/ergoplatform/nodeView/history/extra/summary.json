{
  "folderName": "extra",
  "folderPath": ".autodoc/docs/json/src/main/scala/org/ergoplatform/nodeView/history/extra",
  "url": "https://github.com/ergoplatform/ergo/.autodoc/docs/json/src/main/scala/org/ergoplatform/nodeView/history/extra",
  "files": [
    {
      "fileName": "BalanceInfo.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/history/extra/BalanceInfo.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/history/extra/BalanceInfo.scala",
      "summary": "The `BalanceInfo` class is used to track the ERG and token balances in an `IndexedErgoAddress`. It contains a `nanoErgs` variable to store the balance in nanoERGs and a `tokens` variable to store the balance of each token. The `tokens` variable is an `ArrayBuffer` of tuples, where the first element is the token's `ModifierId` and the second element is the balance of the token.\n\nThe class also has a `mutable.HashMap` called `additionalTokenInfo` to store additional information about each token, such as its name and number of decimals. This information is retrieved from the database using the `retrieveAdditionalTokenInfo` method, which takes an `ErgoHistoryReader` as input and returns the `BalanceInfo` object.\n\nThe `add` method is used to record an address receiving a box. It takes an `ErgoBox` as input and updates the `nanoErgs` and `tokens` variables accordingly. If the token already exists in the `tokens` variable, its balance is updated. Otherwise, a new tuple is added to the `tokens` variable.\n\nThe `subtract` method is used to record an address spending a box. It takes an `ErgoBox` as input and updates the `nanoErgs` and `tokens` variables accordingly. If the token already exists in the `tokens` variable, its balance is updated. If the new balance is zero, the tuple is removed from the `tokens` variable. If the token does not exist in the `tokens` variable, a warning message is logged.\n\nThe `BalanceInfoSerializer` object is used to serialize and deserialize `BalanceInfo` objects. It implements the `ScorexSerializer` trait and provides methods to serialize a `BalanceInfo` object to a `Writer` and parse a `BalanceInfo` object from a `Reader`. The `serialize` method writes the `nanoErgs` and `tokens` variables to the `Writer`, while the `parse` method reads the `nanoErgs` and `tokens` variables from the `Reader` and returns a new `BalanceInfo` object.\n\nOverall, the `BalanceInfo` class is an important component of the `ergo` project, as it provides a way to track the balances of ERG and tokens in an `IndexedErgoAddress`. It can be used to implement various features, such as a wallet or an explorer, that require knowledge of the balances of addresses.",
      "questions": "1. What is the purpose of the `BalanceInfo` class?\n- The `BalanceInfo` class tracks the ERG and token balances in `IndexedErgoAddress`.\n\n2. What is the `retreiveAdditionalTokenInfo` method used for?\n- The `retreiveAdditionalTokenInfo` method is used to get full token information from the database.\n\n3. What is the purpose of the `BalanceInfoSerializer` object?\n- The `BalanceInfoSerializer` object is used to serialize and parse `BalanceInfo` objects."
    },
    {
      "fileName": "ExtraIndexSerializer.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/history/extra/ExtraIndexSerializer.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/history/extra/ExtraIndexSerializer.scala",
      "summary": "The `ExtraIndexSerializer` code is a Scala object that provides serialization and deserialization functionality for objects of type `ExtraIndex`. This object extends the `ScorexSerializer` trait, which is a serialization interface provided by the Scorex library. \n\nThe `serialize` method takes an `ExtraIndex` object and a `Writer` object as input parameters. It then matches the type of the input object with one of several possible cases, each of which corresponds to a different subclass of `ExtraIndex`. Depending on the type of the input object, the method calls the appropriate serializer method for that subclass. For example, if the input object is an instance of `IndexedErgoAddress`, the method calls `IndexedErgoAddressSerializer.serialize` to serialize the object. If the input object is not an instance of any of the known subclasses of `ExtraIndex`, the method throws an error.\n\nThe `parse` method takes a `Reader` object as input parameter and returns an `ExtraIndex` object. It reads a byte from the `Reader` object and matches it with one of several possible cases, each of which corresponds to a different subclass of `ExtraIndex`. Depending on the byte value, the method calls the appropriate parser method for that subclass. For example, if the byte value corresponds to `IndexedErgoAddress.extraIndexTypeId`, the method calls `IndexedErgoAddressSerializer.parse` to deserialize the object. If the byte value does not correspond to any of the known subclasses of `ExtraIndex`, the method throws an error.\n\nOverall, this code provides a way to serialize and deserialize objects of different subclasses of `ExtraIndex` using the Scorex serialization interface. This functionality may be used in the larger project to store and retrieve `ExtraIndex` objects in a serialized format, for example in a database or on disk. Here is an example of how this code might be used:\n\n```\nval extraIndex: ExtraIndex = IndexedErgoAddress(...)\nval writer: Writer = new Writer()\nExtraIndexSerializer.serialize(extraIndex, writer)\nval bytes: Array[Byte] = writer.toBytes\n\n// Later, to deserialize the object:\nval reader: Reader = new Reader(bytes)\nval deserialized: ExtraIndex = ExtraIndexSerializer.parse(reader)\n```",
      "questions": "1. What is the purpose of the `ExtraIndexSerializer` object?\n- The `ExtraIndexSerializer` object is a ScorexSerializer used to serialize and deserialize objects of type `ExtraIndex`.\n\n2. What is the `ScorexSerializer` trait?\n- The `ScorexSerializer` trait is a serialization interface provided by the Scorex framework that defines methods for serializing and deserializing objects.\n\n3. What are the different types of `ExtraIndex` objects that can be serialized and deserialized by this code?\n- The different types of `ExtraIndex` objects that can be serialized and deserialized by this code include `IndexedErgoAddress`, `IndexedErgoTransaction`, `IndexedErgoBox`, `NumericTxIndex`, `NumericBoxIndex`, and `IndexedToken`."
    },
    {
      "fileName": "ExtraIndexer.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/history/extra/ExtraIndexer.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/history/extra/ExtraIndexer.scala",
      "summary": "The `ExtraIndexer` is a part of the Ergo project that constructs an index of database elements to improve the efficiency of querying and accessing data. It is implemented as an Akka actor and is responsible for processing blocks, transactions, and boxes in the Ergo blockchain.\n\nThe `ExtraIndexerBase` trait provides the core functionality for the indexer, including methods for processing blocks, transactions, and boxes, as well as managing the internal state of the indexer. It maintains various buffers for fast access to data, such as `general`, `boxes`, `trees`, and `segments`. The `index` method processes a batch of `BlockTransactions` and updates the internal state accordingly. The `saveProgress` method writes the buffered indexes to the database and clears the buffers for the next batch.\n\nThe `ExtraIndexer` actor extends the `ExtraIndexerBase` trait and handles messages related to starting the indexer, processing new blocks, and performing rollbacks. When a `FullBlockApplied` message is received, the indexer processes the block transactions and updates its internal state. When a `Rollback` message is received, the indexer removes all indexes after a given height and reverts address balances.\n\nThe `ExtraIndexer` can be used in the larger Ergo project to efficiently query and access data related to blocks, transactions, and boxes. It improves the performance of the Ergo node by maintaining an index of database elements and providing fast access to the data.\n\nExample usage:\n\n```scala\nval indexer = ExtraIndexer(chainSettings, cacheSettings)(system)\nindexer ! StartExtraIndexer(history)\n```\n\nThis creates an instance of the `ExtraIndexer` actor and starts the indexing process with the given `history`.",
      "questions": "1. **Question**: What is the purpose of the `ExtraIndexerBase` trait and how does it work?\n   \n   **Answer**: The `ExtraIndexerBase` trait serves as the base for the extra indexer actor and its tests. It provides the core functionality for indexing and managing Ergo transactions, boxes, and addresses. It also handles rollbacks and updates the database with the indexed data.\n\n2. **Question**: How does the `ExtraIndexer` actor interact with the `ErgoHistory` and `HistoryStorage` instances?\n\n   **Answer**: The `ExtraIndexer` actor uses the `ErgoHistory` and `HistoryStorage` instances to read and write data from the database. It subscribes to events such as `FullBlockApplied` and `Rollback` to update its internal state and indexes accordingly. It also uses the `ErgoHistory` instance to access the current chain height and other relevant information.\n\n3. **Question**: What is the purpose of the `index` method in the `ExtraIndexerBase` trait?\n\n   **Answer**: The `index` method in the `ExtraIndexerBase` trait is responsible for processing a batch of `BlockTransactions` and updating the internal state of the indexer. It handles transaction inputs and outputs, updates address balances, and manages the creation and spending of boxes. The method also decides when to write the buffered indexes to the database based on the configured save limit and the current state of the indexer."
    },
    {
      "fileName": "IndexedErgoAddress.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/history/extra/IndexedErgoAddress.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/history/extra/IndexedErgoAddress.scala",
      "summary": "The `IndexedErgoAddress` class in this code represents an index of an Ergo address (ErgoTree) and its associated transactions and boxes. It is used to efficiently query and manipulate the transaction and box data related to a specific address. The class contains methods for adding and spending boxes, retrieving transactions and boxes, and rolling back the state of the address.\n\nThe `IndexedErgoAddress` class has the following main properties:\n\n- `treeHash`: The hash of the corresponding ErgoTree.\n- `txs`: A list of numeric transaction indexes associated with this address.\n- `boxes`: A list of numeric box indexes associated with this address. Negative values indicate the box is spent.\n- `balanceInfo`: Balance information (Optional because fragments do not contain it).\n\nThe class provides methods to:\n\n- Retrieve a range of transactions associated with the address (`retrieveTxs`).\n- Retrieve a range of boxes associated with the address (`retrieveBoxes`).\n- Retrieve a range of unspent boxes associated with the address (`retrieveUtxos`).\n- Add a transaction index to the address (`addTx`).\n- Add a box to the address and update the balance information (`addBox`).\n- Spend a box associated with the address and update the balance information (`spendBox`).\n- Rollback the state of the address and associated boxes (`rollback`).\n- Split the address into segments containing a specific number of transaction and box indexes (`splitToSegments`).\n\nThe `IndexedErgoAddressSerializer` object provides methods to serialize and deserialize `IndexedErgoAddress` instances. It also provides utility functions to compute the Blake2b hash of a given ErgoTree (`hashErgoTree`), calculate the id of an address segment containing box indexes (`boxSegmentId`), and calculate the id of an address segment containing transaction indexes (`txSegmentId`).\n\nThis code is useful in the larger project for efficiently managing and querying address-related data, such as transactions and boxes, and for performing operations like adding and spending boxes, and rolling back the state of an address.",
      "questions": "1. **What is the purpose of the `IndexedErgoAddress` class?**\n\n   The `IndexedErgoAddress` class represents an index of an address (ErgoTree) and contains the hash of the corresponding ErgoTree, a list of numeric transaction indexes associated with the address, a list of numeric box indexes associated with the address, and balance information.\n\n2. **How does the `rollback` method work in the `IndexedErgoAddress` class?**\n\n   The `rollback` method is used to revert the state of the address and its associated boxes to a previous state by removing transaction numbers above a specified target, removing box numbers above a specified target, and reverting the balance. It takes `txTarget`, `boxTarget`, and `_history` as parameters and updates the address in the database accordingly.\n\n3. **What is the purpose of the `splitToSegments` method in the `IndexedErgoAddress` class?**\n\n   The `splitToSegments` method is used to create an array of addresses, each containing a \"segmentTreshold\" number of the address's transaction and box indexes. These special addresses have their ids calculated by \"txSegmentId\" and \"boxSegmentId\" respectively. This method helps in organizing and managing the transaction and box indexes associated with an address."
    },
    {
      "fileName": "IndexedErgoBox.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/history/extra/IndexedErgoBox.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/history/extra/IndexedErgoBox.scala",
      "summary": "The code defines a class called `IndexedErgoBox` which is a wrapper for an `ErgoBox` object with additional information. The additional information includes the height of the block in which the creating transaction was included, the optional id of the spending transaction, the optional height of the block in which the spending transaction was included, the serial number of this output counting from genesis box, and whether or not the box is spent. The class also has methods to fill in spending parameters and check if the box is spent.\n\nThe purpose of this class is to provide a way to index `ErgoBox` objects with additional information for faster retrieval and querying. This is useful in the context of the larger project, which is likely a blockchain or cryptocurrency platform. By indexing `ErgoBox` objects with information such as the height of the block in which they were created and spent, the platform can more efficiently query and analyze the transaction history.\n\nThe code also defines a serializer for the `IndexedErgoBox` class called `IndexedErgoBoxSerializer`. This serializer is used to convert `IndexedErgoBox` objects to and from bytes for storage and transmission. The serializer uses the `ErgoBoxSerializer` to serialize the underlying `ErgoBox` object.\n\nFinally, the code defines an object called `IndexedErgoBox` with a constant `extraIndexTypeId` of 5. This constant is used to identify the type of index in which the `IndexedErgoBox` objects are stored.\n\nExample usage:\n\n```scala\nimport org.ergoplatform.nodeView.history.extra.IndexedErgoBox\n\n// create an IndexedErgoBox object\nval box = new IndexedErgoBox(10, None, None, ergoBox, 12345)\n\n// fill in spending parameters\nbox.asSpent(spendingTxId, spendingHeight)\n\n// check if the box is spent\nval isSpent = box.isSpent\n```",
      "questions": "1. What is the purpose of the `IndexedErgoBox` class?\n- The `IndexedErgoBox` class is a wrapper for an `ErgoBox` with additional information such as the height of the block in which the creating transaction was included and the serial number of the output counting from the genesis box.\n\n2. What is the purpose of the `IndexedErgoBoxSerializer` object?\n- The `IndexedErgoBoxSerializer` object is a Scorex serializer for the `IndexedErgoBox` class, which serializes and deserializes instances of the class.\n\n3. What is the `extraIndexTypeId` value for `IndexedErgoBox`?\n- The `extraIndexTypeId` value for `IndexedErgoBox` is 5."
    },
    {
      "fileName": "IndexedErgoTransaction.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/history/extra/IndexedErgoTransaction.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/history/extra/IndexedErgoTransaction.scala",
      "summary": "The code defines a case class `IndexedErgoTransaction` that represents a transaction in the Ergo blockchain. The purpose of this class is to store the minimum information required for a transaction, rather than the entire transaction, in order to save space. The class has four fields: `txid`, which is the ID of the transaction; `height`, which is the height of the block that includes the transaction; `globalIndex`, which is the serial number of the transaction counting from block 1; and `inputNums`, which is a list of transaction inputs needed for rollback.\n\nThe class also has several methods that retrieve additional information about the transaction from the database. These methods include `blockId`, which returns the ID of the block that includes the transaction; `inclusionHeight`, which returns the height of the block that includes the transaction; `timestamp`, which returns the timestamp of the block that includes the transaction; `index`, which returns the index of the transaction in the block; `numConfirmations`, which returns the number of confirmations for the transaction; `inputs`, which returns a list of the inputs for the transaction; `dataInputs`, which returns a list of the data inputs for the transaction; `outputs`, which returns a list of the outputs for the transaction; and `txSize`, which returns the size of the transaction.\n\nThe `IndexedErgoTransaction` class also includes a `retrieveBody` method that retrieves all information related to the transaction from the database. This method takes a `history` parameter, which is a handle to the database, and returns the transaction augmented with additional information.\n\nThe code also includes two objects: `IndexedErgoTransactionSerializer` and `IndexedErgoTransaction`. The `IndexedErgoTransactionSerializer` object is a serializer for the `IndexedErgoTransaction` class, which is used to serialize and deserialize instances of the class. The `IndexedErgoTransaction` object defines an `extraIndexTypeId` field, which is used to identify the type of the extra index.\n\nOverall, the `IndexedErgoTransaction` class is an important part of the Ergo blockchain project, as it provides a way to store and retrieve information about transactions in a space-efficient manner. It is likely used extensively throughout the project to manage and analyze transactions.",
      "questions": "1. What is the purpose of the `IndexedErgoTransaction` class?\n- The `IndexedErgoTransaction` class is used to store minimum general information for a transaction, such as its ID, height, global index, and input numbers.\n\n2. What is the `retrieveBody` method used for?\n- The `retrieveBody` method is used to retrieve additional information related to a transaction from a database, such as the block ID, inclusion height, timestamp, inputs, data inputs, outputs, and transaction size.\n\n3. What is the purpose of the `IndexedErgoTransactionSerializer` object?\n- The `IndexedErgoTransactionSerializer` object is used to serialize and deserialize instances of the `IndexedErgoTransaction` class, allowing them to be stored and retrieved from a database or transmitted over a network."
    },
    {
      "fileName": "IndexedToken.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/history/extra/IndexedToken.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/history/extra/IndexedToken.scala",
      "summary": "The code defines a token index for the Ergo blockchain. Tokens are created by boxes, and this index tracks the creation information of each token. The `IndexedToken` case class defines the structure of the index, with fields for the token ID, box ID, emission amount, name, description, and number of decimal places. The `uniqueId` method generates a unique identifier for a token, since token IDs can sometimes be identical to box IDs and cause overwrites. The `tokenRegistersSet` method checks if a box is creating a token by verifying that it has additional tokens, registers R4, R5, and R6, and that the registers have the correct type. The `getDecimals` method extracts the number of decimal places from a register, handling both Byte Coll and Int types. \n\nThe `IndexedTokenSerializer` object provides serialization and deserialization methods for the `IndexedToken` class. The `serialize` method writes the fields of an `IndexedToken` object to a `Writer`, while the `parse` method reads the fields from a `Reader` and constructs an `IndexedToken` object. The `fromBox` method constructs an `IndexedToken` object from a box, using the `tokenRegistersSet` and `getDecimals` methods to extract the necessary information. \n\nThis code is used in the larger Ergo project to provide an index of tokens on the blockchain. The index can be used to query information about specific tokens, such as their creation time, amount, and metadata. The `IndexedToken` class and its associated methods provide a standardized format for storing and retrieving token information, making it easier for developers to work with tokens on the Ergo blockchain.",
      "questions": "1. What is the purpose of this code file?\n- This code file contains a case class and two objects related to indexing tokens and their creation information in the Ergo platform.\n\n2. What is the uniqueId method used for?\n- The uniqueId method is used to calculate a unique identifier for a token, which is necessary because token ids are sometimes identical to box ids, which causes overwrites.\n\n3. What is the purpose of the IndexedTokenSerializer object?\n- The IndexedTokenSerializer object is used to serialize and deserialize IndexedToken objects, and also contains methods for checking if a box is creating a token and getting the number of decimal places from a register."
    },
    {
      "fileName": "NumericIndex.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/history/extra/NumericIndex.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/history/extra/NumericIndex.scala",
      "summary": "The code defines two case classes, `NumericTxIndex` and `NumericBoxIndex`, which represent numeric indices pointing to transactions and boxes respectively. These indices are used to retrieve transactions and boxes from a database. \n\nThe `NumericTxIndex` case class takes two parameters: `n`, which is the index number of a transaction, and `m`, which is the id of the transaction. The `NumericBoxIndex` case class takes the same parameters, but for boxes instead of transactions. Both case classes extend the `ExtraIndex` trait, which defines an `id` and a `serializedId` method. The `id` method returns the id of the index, while the `serializedId` method returns the serialized id of the index.\n\nThe `NumericTxIndexSerializer` and `NumericBoxIndexSerializer` objects define methods for serializing and deserializing instances of the `NumericTxIndex` and `NumericBoxIndex` case classes. These methods are used to store and retrieve instances of these case classes from a database.\n\nThe `NumericTxIndex` and `NumericBoxIndex` objects also define two methods each: `indexToBytes` and `getTxByNumber` for `NumericTxIndex`, and `indexToBytes` and `getBoxByNumber` for `NumericBoxIndex`. The `indexToBytes` method takes an index number and returns an id corresponding to that index number. The `getTxByNumber` and `getBoxByNumber` methods take a database handle and an index number, and return the transaction or box with the given index number, if found.\n\nOverall, this code provides a way to retrieve transactions and boxes from a database using numeric indices. It is likely used in the larger project to provide efficient access to transactions and boxes for various operations. For example, it could be used to retrieve a specific transaction or box for validation or processing.",
      "questions": "1. What is the purpose of the `NumericTxIndex` and `NumericBoxIndex` classes?\n- The `NumericTxIndex` and `NumericBoxIndex` classes are used to create numeric indices that point to transaction and box IDs respectively.\n\n2. What is the purpose of the `NumericTxIndexSerializer` and `NumericBoxIndexSerializer` objects?\n- The `NumericTxIndexSerializer` and `NumericBoxIndexSerializer` objects are used to serialize and deserialize instances of the `NumericTxIndex` and `NumericBoxIndex` classes.\n\n3. What is the purpose of the `getTxByNumber` and `getBoxByNumber` methods?\n- The `getTxByNumber` and `getBoxByNumber` methods are used to retrieve transactions and boxes respectively from a database by their index numbers."
    }
  ],
  "folders": [],
  "summary": "The `.autodoc/docs/json/src/main/scala/org/ergoplatform/nodeView/history/extra` folder contains various classes and objects that are used to index and manage data related to Ergo blockchain elements, such as transactions, boxes, and addresses. These indices improve the efficiency of querying and accessing data in the Ergo project.\n\nFor example, the `BalanceInfo` class is used to track ERG and token balances in an `IndexedErgoAddress`. It provides methods to add and subtract boxes, which update the balances accordingly. The `BalanceInfoSerializer` object is used to serialize and deserialize `BalanceInfo` objects.\n\nThe `ExtraIndexSerializer` object provides serialization and deserialization functionality for objects of type `ExtraIndex`, which includes subclasses like `IndexedErgoAddress`, `IndexedErgoBox`, and `IndexedErgoTransaction`. This functionality is used to store and retrieve `ExtraIndex` objects in a serialized format, for example in a database or on disk.\n\nThe `ExtraIndexer` actor is an Akka actor that constructs an index of database elements to improve the efficiency of querying and accessing data. It processes blocks, transactions, and boxes in the Ergo blockchain and maintains various buffers for fast access to data.\n\nThe `IndexedErgoAddress` class represents an index of an Ergo address and its associated transactions and boxes. It provides methods for adding and spending boxes, retrieving transactions and boxes, and rolling back the state of the address. The `IndexedErgoAddressSerializer` object provides methods to serialize and deserialize `IndexedErgoAddress` instances.\n\nThe `IndexedErgoBox` class is a wrapper for an `ErgoBox` object with additional information, such as the height of the block in which the creating transaction was included and whether the box is spent. The `IndexedErgoBoxSerializer` object provides serialization and deserialization methods for the `IndexedErgoBox` class.\n\nThe `IndexedErgoTransaction` class represents a transaction in the Ergo blockchain and stores the minimum information required for a transaction to save space. It provides methods to retrieve additional information about the transaction from the database. The `IndexedErgoTransactionSerializer` object provides serialization and deserialization methods for the `IndexedErgoTransaction` class.\n\nThe `IndexedToken` class defines a token index for the Ergo blockchain, tracking the creation information of each token. The `IndexedTokenSerializer` object provides serialization and deserialization methods for the `IndexedToken` class.\n\nThe `NumericIndex` code defines two case classes, `NumericTxIndex` and `NumericBoxIndex`, which represent numeric indices pointing to transactions and boxes respectively. These indices are used to retrieve transactions and boxes from a database. The `NumericTxIndexSerializer` and `NumericBoxIndexSerializer` objects define methods for serializing and deserializing instances of these case classes.\n\nExample usage of `ExtraIndexer`:\n\n```scala\nval indexer = ExtraIndexer(chainSettings, cacheSettings)(system)\nindexer ! StartExtraIndexer(history)\n```\n\nThis creates an instance of the `ExtraIndexer` actor and starts the indexing process with the given `history`.",
  "questions": ""
}