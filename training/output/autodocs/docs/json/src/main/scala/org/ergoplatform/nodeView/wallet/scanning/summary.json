{
  "folderName": "scanning",
  "folderPath": ".autodoc/docs/json/src/main/scala/org/ergoplatform/nodeView/wallet/scanning",
  "url": "https://github.com/ergoplatform/ergo/.autodoc/docs/json/src/main/scala/org/ergoplatform/nodeView/wallet/scanning",
  "files": [
    {
      "fileName": "Scan.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/wallet/scanning/Scan.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/wallet/scanning/Scan.scala",
      "summary": "This code defines classes and methods related to scanning the Ergo blockchain for specific boxes. The `Scan` class wraps information about a user scan, which provides scanning rules for specific boxes and works with boxes found by the node. It contains a unique identifier for the scan, a description of the scan, a predicate to scan the blockchain for specific scan-related boxes, a flag that prescribes how the scan interacts with the p2pk-wallet, and a flag that prescribes whether box spent offchain should be removed from unspent boxes. \n\nThe `ScanRequest` class encodes an API request to create a scan. It contains a scan description, a predicate to scan the blockchain for specific scan-related boxes, a flag that prescribes how the scan interacts with the p2pk-wallet, and a flag that prescribes whether box spent offchain should be removed from unspent boxes. \n\nThe `ScanSerializer` object defines methods for serializing and parsing `Scan` objects. The `ScanJsonCodecs` object defines JSON codecs for `Scan` and `ScanRequest` objects. \n\nThis code is used in the larger Ergo project to enable users to scan the blockchain for specific boxes and interact with the p2pk-wallet. For example, a user could create a scan to search for boxes that contain a specific token or have a certain value. The `Scan` object would contain the rules for this search, and the `ScanRequest` object would encode an API request to create the scan. The `ScanSerializer` object would handle serialization and parsing of `Scan` objects, and the `ScanJsonCodecs` object would handle JSON encoding and decoding of `Scan` and `ScanRequest` objects.",
      "questions": "1. What is the purpose of the `Scan` case class and how is it used?\n- The `Scan` case class wraps information about a user scan, providing scanning rules for specific boxes and interacting with boxes found by the node. It is used to create a scan request and serialize/deserialize scan data.\n2. What is the `ScanRequest` case class and how does it relate to the `Scan` case class?\n- The `ScanRequest` case class encodes an API request to create a scan, and can be converted to a `Scan` case class using the `toScan` method. It contains the same fields as `Scan`, but with optional values for `walletInteraction` and `removeOffchain`.\n3. What is the purpose of the `ScanSerializer` object and how is it used?\n- The `ScanSerializer` object is a Scorex serializer for the `Scan` case class, used to serialize and deserialize scan data. It includes methods for serializing and parsing `Scan` objects, as well as handling backwards compatibility for previous versions of serialized scans."
    },
    {
      "fileName": "ScanWalletInteraction.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/wallet/scanning/ScanWalletInteraction.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/wallet/scanning/ScanWalletInteraction.scala",
      "summary": "The `ScanWalletInteraction` object defines an enumeration of three possible values for a flag that determines how a scan interacts with an in-built P2PK wallet. The three options are `Off`, `Shared`, and `Forced`. \n\nIf a box associated with a scan has an interaction flag of `Off`, the box will only be added to the scan. If the flag is `Shared`, the box can be in both the wallet and the scan if the wallet finds it (the box is protected by wallet-related P2PK). If the flag is `Forced`, the box is always added to the wallet if it is added to the scan.\n\nThe object also provides three methods for serializing and deserializing the flag to and from a byte value, as well as a method for determining whether a box found for a scan with the given flag should be added to the P2PK wallet.\n\nThis code is likely used in the larger project to manage the interaction between scans and the in-built P2PK wallet. Developers working on the project can use this object to set the interaction flag for a scan and determine whether boxes found during the scan should be added to the wallet. For example, if a developer wants to create a scan that only adds boxes to the scan and not the wallet, they can set the interaction flag to `Off`. \n\nCode example:\n\n```scala\nval scanInteraction = ScanWalletInteraction.Shared\nval shouldAddToWallet = ScanWalletInteraction.interactingWithWallet(scanInteraction)\nprintln(s\"Should add to wallet: $shouldAddToWallet\")\n```\n\nThis code sets the `scanInteraction` variable to `Shared`, indicating that boxes found during the scan can be added to both the scan and the wallet if the wallet finds them. The `interactingWithWallet` method is then called with `scanInteraction` as an argument to determine whether boxes found during the scan should be added to the wallet. The result is printed to the console.",
      "questions": "1. What is the purpose of this code?\n- This code defines an enumeration called `ScanWalletInteraction` which represents the interaction between a scan and an in-built P2PK wallet. It also provides methods for serializing and deserializing the enumeration values.\n\n2. What are the possible values of the `ScanWalletInteraction` enumeration?\n- The possible values are `Off`, `Shared`, and `Forced`. `Off` means that a box associated with a scan with interaction flag == off will only be added to the scan. `Shared` means that a box can be in both the wallet and the scan if the wallet finds it (box is protected by wallet-related P2PK). `Forced` means that a box is always added to the wallet if it is added to the scan.\n\n3. What is the purpose of the `toByte` and `fromByte` methods?\n- The `toByte` method serializes a `ScanWalletInteraction` enumeration value to a byte value representing it. The `fromByte` method deserializes a byte value to a `ScanWalletInteraction` enumeration value. These methods are used in scan deserialization."
    },
    {
      "fileName": "ScanningPredicate.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/wallet/scanning/ScanningPredicate.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/wallet/scanning/ScanningPredicate.scala",
      "summary": "The code defines a set of scanning predicates that can be used to filter ErgoBoxes based on certain criteria. The `ScanningPredicate` trait is the basic interface for all scanning predicates and defines a single method `filter` that takes an `ErgoBox` and returns a boolean indicating whether the box satisfies the predicate or not. \n\nThe `ContainsScanningPredicate` is a scanning predicate that tracks boxes which contain a register that contains a certain value. The `regId` parameter specifies the register identifier to look for, and the `value` parameter specifies the value to track. The `filter` method checks if the box contains the specified register and if the register contains the specified value. The value can be a byte array, in which case the predicate performs a wildcard match, or it can be a group element, boolean, int, or long constant, in which case the predicate performs an exact match.\n\nThe `EqualsScanningPredicate` is a scanning predicate that tracks boxes which contain a register that contains certain bytes. The `regId` parameter specifies the register identifier to look for, and the `value` parameter specifies the bytes to track. The `filter` method checks if the box contains the specified register and if the register contains exactly the specified bytes. The `value` parameter can be a byte array, group element, boolean, int, or long constant.\n\nThe `ContainsAssetPredicate` is a scanning predicate that tracks boxes which contain a certain asset. The `assetId` parameter specifies the asset identifier to look for, and the `filter` method checks if the box contains the specified asset.\n\nThe `AndScanningPredicate` is a scanning predicate that tracks boxes which satisfy all of the sub-predicates at the same time. The `subPredicates` parameter is an arbitrary number of sub-predicates, and the `filter` method checks if the box satisfies all of the sub-predicates.\n\nThe `OrScanningPredicate` is a scanning predicate that tracks boxes which satisfy any of the sub-predicates. The `subPredicates` parameter is an arbitrary number of sub-predicates, and the `filter` method checks if the box satisfies any of the sub-predicates.\n\nThese scanning predicates can be used in the larger project to filter ErgoBoxes based on various criteria. For example, the `ContainsAssetPredicate` can be used to filter boxes that contain a certain token, while the `AndScanningPredicate` and `OrScanningPredicate` can be used to combine multiple predicates to create more complex filters. The `ContainsScanningPredicate` and `EqualsScanningPredicate` can be used to filter boxes based on the values of their registers. Overall, these scanning predicates provide a flexible and powerful way to filter ErgoBoxes based on various criteria.",
      "questions": "1. What is the purpose of this code and how does it fit into the overall ergo project?\n- This code provides a set of scanning predicates for tracking ErgoBoxes based on certain criteria, such as the presence of a specific register or asset. It is part of the wallet scanning functionality in the Ergo project.\n\n2. What are the different types of scanning predicates available and how do they work?\n- There are four types of scanning predicates: ContainsScanningPredicate, EqualsScanningPredicate, ContainsAssetPredicate, AndScanningPredicate, and OrScanningPredicate. ContainsScanningPredicate and EqualsScanningPredicate track boxes based on the presence of a specific register value, with ContainsScanningPredicate using wildcard matching and EqualsScanningPredicate using exact matching. ContainsAssetPredicate tracks boxes based on the presence of a specific asset. AndScanningPredicate tracks boxes that satisfy all of its sub-predicates, while OrScanningPredicate tracks boxes that satisfy any of its sub-predicates.\n\n3. What is the purpose of the `filter` method in each scanning predicate and how is it used?\n- The `filter` method takes an ErgoBox as input and returns a Boolean indicating whether the box satisfies the scanning predicate's criteria. It is used to determine which boxes should be included in the results of a wallet scan based on the specified predicate."
    },
    {
      "fileName": "ScanningPredicateJsonCodecs.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/wallet/scanning/ScanningPredicateJsonCodecs.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/wallet/scanning/ScanningPredicateJsonCodecs.scala",
      "summary": "The `ScanningPredicateJsonCodecs` object contains implicit encoders and decoders for the `ScanningPredicate` trait and its subtypes. This object is used to encode and decode `ScanningPredicate` objects to and from JSON format. \n\nThe `ScanningPredicate` trait is used to define predicates that can be used to scan Ergo boxes. The subtypes of `ScanningPredicate` are `ContainsScanningPredicate`, `EqualsScanningPredicate`, `ContainsAssetPredicate`, `AndScanningPredicate`, and `OrScanningPredicate`. \n\nThe `ContainsScanningPredicate` subtype is used to check if a given register of an Ergo box contains a specific value. The `EqualsScanningPredicate` subtype is used to check if a given register of an Ergo box is equal to a specific value. The `ContainsAssetPredicate` subtype is used to check if an Ergo box contains a specific asset. The `AndScanningPredicate` and `OrScanningPredicate` subtypes are used to combine multiple `ScanningPredicate` objects with logical AND and OR operations, respectively.\n\nThe `scanningPredicateEncoder` implicit encoder encodes a `ScanningPredicate` object to JSON format. Depending on the subtype of the `ScanningPredicate` object, the encoder encodes different fields. For example, if the `ScanningPredicate` object is of type `ContainsScanningPredicate`, the encoder encodes the register ID and the value to check for. \n\nThe `scanningPredicateDecoder` implicit decoder decodes a JSON object to a `ScanningPredicate` object. Depending on the value of the `\"predicate\"` field in the JSON object, the decoder decodes different fields. For example, if the `\"predicate\"` field is `\"contains\"`, the decoder decodes the register ID and the value to check for.\n\nThis object is used in the larger project to encode and decode `ScanningPredicate` objects to and from JSON format. This is useful for communication between different parts of the project that need to scan Ergo boxes using different predicates. For example, the wallet module may use this object to encode and decode `ScanningPredicate` objects to and from JSON format when communicating with the node module to scan Ergo boxes for specific assets or values. \n\nExample usage:\n\n```scala\nimport org.ergoplatform.nodeView.wallet.scanning._\n\n// create a ContainsScanningPredicate object\nval containsPredicate = ContainsScanningPredicate(ErgoBox.R4, 42)\n\n// encode the ContainsScanningPredicate object to JSON format\nval json = containsPredicate.asJson\n\n// decode the JSON object to a ScanningPredicate object\nval decodedPredicate = json.as[ScanningPredicate]\n```",
      "questions": "1. What is the purpose of the `ScanningPredicate` class and its subclasses?\n- The `ScanningPredicate` class and its subclasses define different types of predicates used for scanning Ergo boxes.\n2. What is the role of the `scanningPredicateEncoder` and `scanningPredicateDecoder` implicits?\n- The `scanningPredicateEncoder` and `scanningPredicateDecoder` implicits provide encoding and decoding functionality for the `ScanningPredicate` class and its subclasses to and from JSON format.\n3. What is the purpose of the `ApiCodecs` import?\n- The `ApiCodecs` import provides additional codecs for encoding and decoding JSON objects used in the Ergo API."
    },
    {
      "fileName": "ScanningPredicateSerializer.scala",
      "filePath": "src/main/scala/org/ergoplatform/nodeView/wallet/scanning/ScanningPredicateSerializer.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/nodeView/wallet/scanning/ScanningPredicateSerializer.scala",
      "summary": "The `ScanningPredicateSerializer` object is responsible for serializing and deserializing `ScanningPredicate` objects. `ScanningPredicate` is an abstract class that represents a predicate used to scan Ergo boxes. Ergo boxes are data structures that store assets and are used in the Ergo blockchain. The `ScanningPredicate` class has several concrete implementations, including `EqualsScanningPredicate`, `ContainsScanningPredicate`, `ContainsAssetPredicate`, `AndScanningPredicate`, and `OrScanningPredicate`. \n\nThe `serialize` method takes a `ScanningPredicate` object and a `Writer` object and writes the object to the writer in a binary format. The `parse` method takes a `Reader` object and reads a binary representation of a `ScanningPredicate` object from it. The `parse` method uses helper subfunctions to parse the binary data. \n\nThe `EqualsScanningPredicate` and `ContainsScanningPredicate` implementations serialize the register identifier and the value to compare against. The `ContainsAssetPredicate` implementation serializes the asset identifier. The `AndScanningPredicate` and `OrScanningPredicate` implementations serialize an array of sub-predicates. \n\nThis code is used in the larger Ergo project to serialize and deserialize scanning predicates. Scanning predicates are used to search for Ergo boxes that meet certain criteria. For example, a scanning predicate could be used to find all boxes that contain a certain asset or all boxes that have a certain value in a certain register. The `ScanningPredicateSerializer` object is used to serialize and deserialize these predicates so that they can be stored and transmitted efficiently. \n\nExample usage:\n\n```scala\nval predicate = EqualsScanningPredicate(ErgoBox.R4, IntConstant(42))\nval writer = new ByteArrayWriter()\nScanningPredicateSerializer.serialize(predicate, writer)\nval bytes = writer.toBytes\n\nval reader = new ByteArrayReader(bytes)\nval parsedPredicate = ScanningPredicateSerializer.parse(reader)\nassert(parsedPredicate == predicate)\n```",
      "questions": "1. What is the purpose of this code and how does it fit into the overall ergo project?\n- This code is a serializer for scanning predicates used in the ergo wallet. It allows for serialization and deserialization of scanning predicates. It is part of the wallet scanning functionality in the ergo project.\n\n2. What are the different types of scanning predicates that can be serialized by this code?\n- There are five different types of scanning predicates that can be serialized by this code: EqualsScanningPredicate, ContainsScanningPredicate, ContainsAssetPredicate, AndScanningPredicate, and OrScanningPredicate.\n\n3. What is the role of the helper subfunctions in the parse method?\n- The helper subfunctions in the parse method are used to parse the arguments and register values for the different types of scanning predicates. They help to simplify the parsing process and make the code more readable."
    }
  ],
  "folders": [],
  "summary": "The code in this folder is responsible for scanning the Ergo blockchain for specific boxes based on user-defined criteria. It provides classes and methods for creating, serializing, and deserializing scans, as well as defining scanning predicates to filter boxes based on various conditions.\n\nThe `Scan` class wraps information about a user scan, which provides scanning rules for specific boxes and works with boxes found by the node. The `ScanRequest` class encodes an API request to create a scan. The `ScanSerializer` object defines methods for serializing and parsing `Scan` objects, and the `ScanJsonCodecs` object defines JSON codecs for `Scan` and `ScanRequest` objects.\n\nThe `ScanWalletInteraction` object defines an enumeration of three possible values for a flag that determines how a scan interacts with an in-built P2PK wallet. Developers can use this object to set the interaction flag for a scan and determine whether boxes found during the scan should be added to the wallet.\n\nThe `ScanningPredicate` trait and its subtypes define a set of scanning predicates that can be used to filter ErgoBoxes based on certain criteria. These scanning predicates provide a flexible and powerful way to filter ErgoBoxes based on various criteria, such as containing a specific asset or having a certain value in a register.\n\nThe `ScanningPredicateJsonCodecs` object contains implicit encoders and decoders for the `ScanningPredicate` trait and its subtypes, enabling encoding and decoding of `ScanningPredicate` objects to and from JSON format. The `ScanningPredicateSerializer` object is responsible for serializing and deserializing `ScanningPredicate` objects in binary format.\n\nExample usage:\n\n```scala\nimport org.ergoplatform.nodeView.wallet.scanning._\n\n// Create a ContainsAssetPredicate to find boxes containing a specific asset\nval assetId = \"someAssetId\"\nval predicate = ContainsAssetPredicate(assetId)\n\n// Create a Scan object with the predicate and other parameters\nval scanId = 1\nval scanDescription = \"Scan for boxes containing asset\"\nval scanInteraction = ScanWalletInteraction.Shared\nval removeOffchain = false\nval scan = Scan(scanId, scanDescription, predicate, scanInteraction, removeOffchain)\n\n// Serialize and deserialize the Scan object\nval json = scan.asJson\nval decodedScan = json.as[Scan]\n\n// Use the Scan object to search for boxes in the Ergo blockchain\nval boxes = searchForBoxes(scan)\n```\n\nIn the larger Ergo project, this code enables users to scan the blockchain for specific boxes and interact with the p2pk-wallet. For example, a user could create a scan to search for boxes that contain a specific token or have a certain value. The `Scan` object would contain the rules for this search, and the `ScanRequest` object would encode an API request to create the scan. The `ScanSerializer` object would handle serialization and parsing of `Scan` objects, and the `ScanJsonCodecs` object would handle JSON encoding and decoding of `Scan` and `ScanRequest` objects.",
  "questions": ""
}