{
  "folderName": "difficulty",
  "folderPath": ".autodoc/docs/json/src/main/scala/org/ergoplatform/mining/difficulty",
  "url": "https://github.com/ergoplatform/ergo/.autodoc/docs/json/src/main/scala/org/ergoplatform/mining/difficulty",
  "files": [
    {
      "fileName": "DifficultyAdjustment.scala",
      "filePath": "src/main/scala/org/ergoplatform/mining/difficulty/DifficultyAdjustment.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/mining/difficulty/DifficultyAdjustment.scala",
      "summary": "The `DifficultyAdjustment` class is used to calculate the difficulty of mining a block in the Ergo blockchain. The difficulty is adjusted periodically to ensure that blocks are mined at a consistent rate. The class contains methods for calculating the difficulty using two different algorithms: one based on Bitcoin's difficulty adjustment algorithm, and another based on EIP-37.\n\nThe `DifficultyAdjustment` class takes a `ChainSettings` object as a parameter, which contains various settings related to the blockchain, such as the block interval, the number of epochs to use for difficulty calculation, and the initial difficulty. The class also has a `ScorexLogging` trait, which provides logging functionality.\n\nThe `previousHeadersRequiredForRecalculation` method takes a block height and an epoch length as parameters and returns the heights of the previous headers required for block recalculation. The method checks if the block height is a multiple of the epoch length and returns the heights of the previous headers for the last `useLastEpochs` epochs. If the block height is not a multiple of the epoch length, it returns the height of the previous header.\n\nThe `bitcoinCalculate` method takes a sequence of headers and an epoch length as parameters and calculates the difficulty using Bitcoin's difficulty adjustment algorithm. The method takes the last two headers from the sequence and passes them to the `bitcoinCalculate` method that takes two headers as parameters. The `bitcoinCalculate` method calculates the difficulty based on the timestamps and required difficulties of the two headers.\n\nThe `eip37Calculate` method takes a sequence of headers and an epoch length as parameters and calculates the difficulty using the EIP-37 algorithm. The method requires at least two headers in the sequence and calculates the predictive difficulty and the limited predictive difficulty based on the previous headers. The method then calculates the classic difficulty using the `bitcoinCalculate` method and takes the average of the classic difficulty and the limited predictive difficulty. The method then calculates the uncompressed difficulty based on the average difficulty and the last difficulty. Finally, the method normalizes the difficulty using the `RequiredDifficulty` class.\n\nThe `calculate` method takes a sequence of headers and an epoch length as parameters and calculates the difficulty using a custom algorithm. The method checks if the sequence contains at least one header and returns the required difficulty of the first header if there is only one header. Otherwise, the method calculates the difficulty for each pair of adjacent headers in the sequence and interpolates the difficulties to get the difficulty for the next block. The method normalizes the difficulty using the `RequiredDifficulty` class.\n\nThe `interpolate` method takes a sequence of data points and an epoch length as parameters and interpolates the data points using a linear regression algorithm. The method calculates the slope and intercept of the regression line and returns the y-value of the line for the next data point.\n\nOverall, the `DifficultyAdjustment` class provides methods for calculating the difficulty of mining a block in the Ergo blockchain using different algorithms. These methods are used to adjust the difficulty periodically to ensure that blocks are mined at a consistent rate.",
      "questions": "1. What is the purpose of the `DifficultyAdjustment` class?\n- The `DifficultyAdjustment` class is used to adjust the difficulty of mining blocks in the Ergo blockchain based on various factors.\n\n2. What is the difference between `bitcoinCalculate` and `eip37Calculate` methods?\n- The `bitcoinCalculate` method calculates the difficulty of mining blocks based on the Bitcoin algorithm, while the `eip37Calculate` method calculates the difficulty based on the EIP-37 algorithm.\n\n3. What is the purpose of the `interpolate` method?\n- The `interpolate` method is used to calculate the difficulty of mining blocks based on a set of previous headers, by interpolating between the difficulties of those headers."
    },
    {
      "fileName": "RequiredDifficulty.scala",
      "filePath": "src/main/scala/org/ergoplatform/mining/difficulty/RequiredDifficulty.scala",
      "url": "https://github.com/ergoplatform/ergo/src/main/scala/org/ergoplatform/mining/difficulty/RequiredDifficulty.scala",
      "summary": "The `RequiredDifficulty` object in the `org.ergoplatform.mining.difficulty` package provides methods for encoding and decoding compact difficulty targets used in the Ergo blockchain. The `encodeCompactBits` method takes a `BigInt` representing the required difficulty and returns a `Long` in the compact format. The `decodeCompactBits` method takes a `Long` in the compact format and returns a `BigInt` representing the required difficulty. \n\nThe compact format is a 32-bit unsigned integer that represents a whole number `N` using a floating-point-like format. The most significant 8 bits represent the unsigned exponent of base 256, which can be thought of as the number of bytes of `N`. The lower 23 bits represent the mantissa. Bit number 24 (0x800000) represents the sign of `N`. Therefore, `N = (-1^sign) * mantissa * 256^(exponent-3)`. \n\nThe `readUint32BE` and `uint32ToByteArrayBE` methods are used to parse and serialize unsigned 32-bit integers in big-endian format. The `decodeMPI` method is used to decode MPI-encoded numbers produced by the OpenSSL BN_bn2mpi function. They consist of a 4-byte big-endian length field, followed by the stated number of bytes representing the number in big-endian format (with a sign bit). \n\nThis object is used in the larger Ergo project to calculate and verify the required difficulty for mining blocks in the blockchain. For example, when a new block is mined, its difficulty is calculated and encoded in the compact format using the `encodeCompactBits` method. This encoded difficulty is then included in the block header and broadcast to the network. When a node receives a new block, it decodes the difficulty using the `decodeCompactBits` method and verifies that it meets the required difficulty for the blockchain. \n\nExample usage:\n\n```scala\nimport org.ergoplatform.mining.difficulty.RequiredDifficulty\n\nval requiredDifficulty: BigInt = BigInt(\"12345678901234567890\")\nval compactDifficulty: Long = RequiredDifficulty.encodeCompactBits(requiredDifficulty)\nprintln(compactDifficulty) // prints 0x1b0404cb\nval decodedDifficulty: BigInt = RequiredDifficulty.decodeCompactBits(compactDifficulty)\nprintln(decodedDifficulty) // prints 12345678901234567890\n```",
      "questions": "1. What is the purpose of the `RequiredDifficulty` object?\n- The `RequiredDifficulty` object provides methods for encoding and decoding compact bits used for encoding difficulty targets in Bitcoin.\n\n2. What is the `ScorexSerializer` trait used for?\n- The `ScorexSerializer` trait is used for serializing and deserializing objects in the Scorex framework.\n\n3. What is the purpose of the `decodeMPI` method?\n- The `decodeMPI` method is used for decoding MPI encoded numbers produced by the OpenSSL BN_bn2mpi function."
    }
  ],
  "folders": [],
  "summary": "The `org.ergoplatform.mining.difficulty` package in the Ergo project contains two main files: `DifficultyAdjustment.scala` and `RequiredDifficulty.scala`. These files are responsible for calculating and adjusting the mining difficulty in the Ergo blockchain, ensuring that blocks are mined at a consistent rate.\n\n`DifficultyAdjustment.scala` provides a class with methods for calculating the difficulty using different algorithms, such as Bitcoin's difficulty adjustment algorithm and EIP-37. The class takes a `ChainSettings` object as a parameter, which contains various settings related to the blockchain. The main method, `calculate`, takes a sequence of headers and an epoch length as parameters and calculates the difficulty using a custom algorithm. The difficulty is then normalized using the `RequiredDifficulty` class.\n\n`RequiredDifficulty.scala` provides methods for encoding and decoding compact difficulty targets used in the Ergo blockchain. The `encodeCompactBits` method takes a `BigInt` representing the required difficulty and returns a `Long` in the compact format. The `decodeCompactBits` method takes a `Long` in the compact format and returns a `BigInt` representing the required difficulty.\n\nHere's an example of how these classes might be used together:\n\n```scala\nimport org.ergoplatform.mining.difficulty.{DifficultyAdjustment, RequiredDifficulty}\nimport org.ergoplatform.settings.ChainSettings\n\nval chainSettings = ChainSettings(...)\nval difficultyAdjustment = new DifficultyAdjustment(chainSettings)\n\nval previousHeaders = Seq(...) // a sequence of previous block headers\nval epochLength = 1024\n\n// Calculate the difficulty for the next block\nval nextDifficulty = difficultyAdjustment.calculate(previousHeaders, epochLength)\n\n// Encode the difficulty in the compact format\nval compactDifficulty = RequiredDifficulty.encodeCompactBits(nextDifficulty)\n\n// Decode the difficulty from the compact format\nval decodedDifficulty = RequiredDifficulty.decodeCompactBits(compactDifficulty)\n```\n\nIn summary, the `org.ergoplatform.mining.difficulty` package provides essential functionality for adjusting the mining difficulty in the Ergo blockchain. The `DifficultyAdjustment` class calculates the difficulty using various algorithms, while the `RequiredDifficulty` object encodes and decodes the difficulty in a compact format. These classes work together to ensure that blocks are mined at a consistent rate, maintaining the stability and security of the Ergo blockchain.",
  "questions": ""
}